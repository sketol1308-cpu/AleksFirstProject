<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatApp - Messages</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <button class="back-btn" id="backBtn" onclick="backToPublicChat()" style="display: none;">â† Back</button>
            <div class="user-info">
                <div class="user-avatar" id="currentUserAvatar">ğŸ˜€</div>
                <div class="user-details">
                    <h2 id="currentUsername">User</h2>
                    <p id="chatMode">Public Chat</p>
                </div>
            </div>
            <div class="header-actions">
                <button class="call-btn" id="callBtn" onclick="startCall()" style="display: none;" title="Start Call">ğŸ“</button>
                <button class="notification-toggle-btn" id="notificationIcon" onclick="toggleNotifications()" title="Notifications ON">ğŸ””</button>
                <button class="settings-btn" onclick="openProfileSettings()" title="Profile Settings">âš™ï¸</button>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <div class="users-section">
            <div class="users-tabs">
                <button class="users-tab active" id="onlineTab" onclick="switchUsersTab('online')">
                    ONLINE (<span id="onlineCount">0</span>)
                </button>
                <button class="users-tab" id="allUsersTab" onclick="switchUsersTab('all')">
                    ALL USERS (<span id="allUsersCount">0</span>)
                </button>
            </div>
            <div class="users-list" id="usersList"></div>
        </div>

        <div class="messages-area" id="messagesArea">
            <div class="empty-state">
                <div class="empty-icon">ğŸ’¬</div>
                <p>Start chatting with others!</p>
            </div>
        </div>

        <div class="typing-indicator" id="typingIndicator" style="display: none;">
            <span id="typingText"></span>
            <span class="typing-dots">
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
            </span>
        </div>

        <!-- User Profile View Modal -->
        <div class="user-profile-modal" id="userProfileModal" style="display: none;">
            <div class="user-profile-content">
                <div class="user-profile-header">
                    <h2>User Profile</h2>
                    <button class="close-modal-btn" id="closeUserProfileBtn">âœ•</button>
                </div>

                <div class="user-profile-body">
                    <div class="profile-avatar-large" id="viewProfileAvatar">ğŸ˜€</div>
                    <h3 id="viewProfileUsername">Username</h3>
                    <div class="profile-info">
                        <div class="profile-info-item">
                            <span class="profile-info-label">Member Since</span>
                            <span class="profile-info-value" id="viewProfileJoined">Just now</span>
                        </div>
                        <div class="profile-info-item">
                            <span class="profile-info-label">User ID</span>
                            <span class="profile-info-value" id="viewProfileId">-</span>
                        </div>
                    </div>
                    <button class="chat-with-user-btn" id="chatWithUserBtn">Send Message</button>
                </div>
            </div>
        </div>

        <!-- Profile Settings Modal -->
        <div class="profile-modal" id="profileModal" style="display: none;">
            <div class="profile-modal-content">
                <div class="profile-modal-header">
                    <h2>Profile Settings</h2>
                    <button class="close-modal-btn" onclick="closeProfileSettings()">âœ•</button>
                </div>

                <div class="profile-section">
                    <h3>Avatar</h3>
                    <div class="current-avatar-display">
                        <div class="big-avatar" id="currentAvatarDisplay">ğŸ˜€</div>
                    </div>
                    <div class="avatar-selector" id="profileAvatarSelector">
                        <div class="avatar-option" data-avatar="ğŸ˜€">ğŸ˜€</div>
                        <div class="avatar-option" data-avatar="ğŸ˜">ğŸ˜</div>
                        <div class="avatar-option" data-avatar="ğŸ¤©">ğŸ¤©</div>
                        <div class="avatar-option" data-avatar="ğŸ¥³">ğŸ¥³</div>
                        <div class="avatar-option" data-avatar="ğŸ˜º">ğŸ˜º</div>
                        <div class="avatar-option" data-avatar="ğŸ¦Š">ğŸ¦Š</div>
                        <div class="avatar-option" data-avatar="ğŸ¼">ğŸ¼</div>
                        <div class="avatar-option" data-avatar="ğŸ¦„">ğŸ¦„</div>
                    </div>
                    <button class="save-profile-btn" onclick="updateAvatar()">Save Avatar</button>
                </div>

                <div class="profile-section">
                    <h3>Username</h3>
                    <div class="input-group">
                        <label for="newUsername">New Username</label>
                        <input type="text" id="newUsername" placeholder="Enter new username" minlength="3">
                    </div>
                    <button class="save-profile-btn" onclick="updateUsername()">Save Username</button>
                </div>

                <div class="profile-section">
                    <h3>Change Password</h3>
                    <div class="input-group">
                        <label for="currentPassword">Current Password</label>
                        <input type="password" id="currentPassword" placeholder="Enter current password" minlength="6">
                    </div>
                    <div class="input-group">
                        <label for="newPassword">New Password</label>
                        <input type="password" id="newPassword" placeholder="Enter new password" minlength="6">
                    </div>
                    <div class="input-group">
                        <label for="confirmNewPassword">Confirm New Password</label>
                        <input type="password" id="confirmNewPassword" placeholder="Confirm new password" minlength="6">
                    </div>
                    <button class="save-profile-btn" onclick="updatePassword()">Change Password</button>
                </div>

                <div id="profileMessage" style="display: none;"></div>
            </div>
        </div>

        <div class="input-area">
            <div class="emoji-picker" id="emojiPicker" style="display: none;">
                <div class="emoji-header">
                    <span class="emoji-category active" data-category="smileys">ğŸ˜€</span>
                    <span class="emoji-category" data-category="gestures">ğŸ‘‹</span>
                    <span class="emoji-category" data-category="hearts">â¤ï¸</span>
                    <span class="emoji-category" data-category="animals">ğŸ¶</span>
                    <span class="emoji-category" data-category="food">ğŸ•</span>
                    <span class="emoji-category" data-category="activities">âš½</span>
                    <span class="emoji-category" data-category="objects">ğŸ’¡</span>
                </div>
                <div class="emoji-grid" id="emojiGrid"></div>
            </div>
            <div class="input-container">
                <button class="emoji-btn" id="emojiBtn" onclick="toggleEmojiPicker()">ğŸ˜Š</button>
                <button class="image-btn" id="imageBtn" onclick="document.getElementById('imageInput').click()" title="Send Image/GIF">ğŸ“·</button>
                <button class="gif-btn" id="gifBtn" onclick="toggleGifPicker()" title="Search GIFs">GIF</button>
                <button class="gift-btn" id="giftBtn" onclick="toggleGiftPicker()" title="Send a Gift">ğŸ</button>
                <input type="file" id="imageInput" accept="image/*,image/gif" style="display: none;">
                <input
                    type="text"
                    class="message-input"
                    id="messageInput"
                    placeholder="Type a message..."
                    maxlength="500"
                    autocomplete="off"
                >
                <button class="send-btn" onclick="sendMessage()">Send</button>
            </div>

            <!-- GIF Picker -->
            <div class="gif-picker" id="gifPicker" style="display: none;">
                <div class="gif-picker-header">
                    <input type="text" id="gifSearchInput" placeholder="Search GIFs..." class="gif-search-input">
                    <button class="gif-close-btn" onclick="toggleGifPicker()">âœ•</button>
                </div>
                <div class="gif-grid" id="gifGrid">
                    <div class="gif-loading">Loading trending GIFs...</div>
                </div>
            </div>

            <!-- Gift Picker -->
            <div class="gift-picker" id="giftPicker" style="display: none;">
                <div class="gift-picker-header">
                    <span class="gift-picker-title">Send a Gift</span>
                    <button class="gift-close-btn" onclick="toggleGiftPicker()">âœ•</button>
                </div>
                <div class="gift-grid" id="giftGrid"></div>
            </div>
        </div>
    </div>

    <!-- Call Modal -->
    <div class="call-modal" id="callModal" style="display: none;">
        <div class="call-content">
            <div class="call-avatar" id="callAvatar">ğŸ˜€</div>
            <h2 class="call-username" id="callUsername">Username</h2>
            <p class="call-status" id="callStatus">Calling...</p>

            <div class="call-timer" id="callTimer" style="display: none;">00:00</div>

            <div class="call-controls">
                <button class="call-control-btn mute-btn" id="muteBtn" onclick="toggleMute()" style="display: none;" title="Mute">
                    <span id="muteIcon">ğŸ¤</span>
                </button>
                <button class="call-control-btn video-btn" id="videoBtn" onclick="toggleVideo()" style="display: none;" title="Toggle Video">
                    <span id="videoIcon">ğŸ“¹</span>
                </button>
                <button class="call-control-btn end-btn" id="endBtn" onclick="endCall()">
                    ğŸ“
                </button>
            </div>

            <!-- Video elements -->
            <div class="video-container" id="videoContainer" style="display: none;">
                <video id="localVideo" autoplay muted playsinline></video>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
    </div>

    <!-- Incoming Call Modal -->
    <div class="incoming-call-modal" id="incomingCallModal" style="display: none;">
        <div class="incoming-call-content">
            <div class="call-avatar" id="incomingCallAvatar">ğŸ˜€</div>
            <h2 class="call-username" id="incomingCallUsername">Username</h2>
            <p class="call-status">Incoming Call...</p>

            <div class="incoming-call-actions">
                <button class="accept-call-btn" onclick="acceptCall()">
                    ğŸ“ Accept
                </button>
                <button class="reject-call-btn" onclick="rejectCall()">
                    âœ• Reject
                </button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // YOUR REAL Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAM9AVeKv8po7D16h6XM422Eh0heq3hAW0",
            authDomain: "chat-app-with-claude.firebaseapp.com",
            databaseURL: "https://chat-app-with-claude-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "chat-app-with-claude",
            storageBucket: "chat-app-with-claude.firebasestorage.app",
            messagingSenderId: "163903134612",
            appId: "1:163903134612:web:8317fa2bc619563d0b8d81"
        };

        let database;

        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('âœ… Firebase Database connected!');
        } catch (error) {
            console.error('âŒ Firebase error:', error);
            alert('Error connecting to Firebase: ' + error.message);
        }

        const currentUser = JSON.parse(localStorage.getItem('chatapp_user'));

        if (!currentUser) {
            window.location.href = 'index.html';
        }

        document.getElementById('currentUserAvatar').textContent = currentUser.avatar;
        document.getElementById('currentUsername').textContent = currentUser.username;

        // Chat mode: 'public' or 'private'
        let chatMode = 'public';
        let selectedUser = null;

        // Users display mode: 'online' or 'all'
        let usersDisplayMode = 'online';
        let allUsersData = {};
        let onlineUsersData = {};

        // Notification sounds
        let notificationEnabled = localStorage.getItem('chatapp_notifications') !== 'false';
        let browserNotificationsAllowed = localStorage.getItem('chatapp_notifications_allowed') === 'true';
        let previousMessageIds = new Set();

        // Audio context for notifications (initialized on first user interaction)
        let audioContext = null;
        let audioContextInitialized = false;

        // Initialize audio context (called on user interaction)
        function initAudioContext() {
            if (audioContextInitialized) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContextInitialized = true;
                console.log('Audio context initialized');

                // Resume context if suspended (Safari/iOS requirement)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.error('Error initializing audio context:', error);
            }
        }

        // Initialize audio on any user interaction
        const initAudioEvents = ['click', 'touchstart', 'keydown'];
        initAudioEvents.forEach(event => {
            document.addEventListener(event, initAudioContext, { once: true });
        });

        // Create notification sound using Web Audio API (mobile-friendly)
        function playNotificationSound() {
            if (!notificationEnabled) return;

            try {
                // Initialize audio context if not done yet
                if (!audioContextInitialized) {
                    initAudioContext();
                }

                if (!audioContext) {
                    console.warn('Audio context not available');
                    return;
                }

                // Resume context if suspended (important for mobile)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playSound();
                    }).catch(err => {
                        console.error('Failed to resume audio context:', err);
                    });
                } else {
                    playSound();
                }

                function playSound() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                }
            } catch (error) {
                console.error('Error playing notification sound:', error);
            }
        }

        // Show browser notification
        function showBrowserNotification(username, message, avatar) {
            if (!browserNotificationsAllowed) return;
            if (!("Notification" in window)) return;
            if (Notification.permission !== "granted") return;

            // Don't show notification if window is focused
            if (document.hasFocus()) return;

            try {
                const notification = new Notification(`${avatar} ${username}`, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">' + avatar + '</text></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">ğŸ’¬</text></svg>',
                    tag: 'chatapp-message',
                    requireInteraction: false,
                    silent: true // We already have sound notification
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };

                // Auto close after 5 seconds
                setTimeout(() => {
                    notification.close();
                }, 5000);
            } catch (error) {
                console.error('Error showing browser notification:', error);
            }
        }

        function toggleNotifications() {
            notificationEnabled = !notificationEnabled;
            localStorage.setItem('chatapp_notifications', notificationEnabled);
            updateNotificationIcon();
        }

        function updateNotificationIcon() {
            const icon = document.getElementById('notificationIcon');
            if (icon) {
                icon.textContent = notificationEnabled ? 'ğŸ””' : 'ğŸ”•';
                icon.title = notificationEnabled ? 'Notifications ON' : 'Notifications OFF';
            }
        }

        // Visual notification flash (mobile-friendly fallback)
        function flashNotification() {
            if (!notificationEnabled) return;

            try {
                const header = document.querySelector('.chat-header');
                if (!header) return;

                // Add flash animation
                header.style.animation = 'none';
                setTimeout(() => {
                    header.style.animation = 'headerFlash 0.5s ease-out';
                }, 10);

                // Reset animation after completion
                setTimeout(() => {
                    header.style.animation = '';
                }, 600);
            } catch (error) {
                console.error('Error showing visual notification:', error);
            }
        }

        // Set initial notification icon state
        setTimeout(() => {
            updateNotificationIcon();
        }, 100);

        // Mark user as online
        const onlineUserRef = database.ref('online/' + currentUser.id);
        onlineUserRef.set({
            username: currentUser.username,
            avatar: currentUser.avatar,
            lastSeen: firebase.database.ServerValue.TIMESTAMP
        });

        // Remove user when they disconnect
        onlineUserRef.onDisconnect().remove();

        // Remove typing status when they disconnect
        database.ref('typing/public/' + currentUser.id).onDisconnect().remove();

        // Listen for online users
        database.ref('online').on('value', (snapshot) => {
            onlineUsersData = snapshot.val() || {};
            updateUsersDisplay();
        });

        // Listen for all users
        database.ref('users').on('value', (snapshot) => {
            allUsersData = snapshot.val() || {};
            updateUsersDisplay();
        });

        // Switch between online and all users tabs
        function switchUsersTab(mode) {
            usersDisplayMode = mode;

            const onlineTab = document.getElementById('onlineTab');
            const allUsersTab = document.getElementById('allUsersTab');

            if (mode === 'online') {
                onlineTab.classList.add('active');
                allUsersTab.classList.remove('active');
            } else {
                onlineTab.classList.remove('active');
                allUsersTab.classList.add('active');
            }

            updateUsersDisplay();
        }

        // Update users display based on current mode
        function updateUsersDisplay() {
            const usersList = document.getElementById('usersList');
            const onlineCount = document.getElementById('onlineCount');
            const allUsersCount = document.getElementById('allUsersCount');

            usersList.innerHTML = '';

            // Count online users (excluding current user)
            let onlineUserCount = 0;
            for (let userId in onlineUsersData) {
                if (userId !== currentUser.id) {
                    onlineUserCount++;
                }
            }

            // Count all users (excluding current user)
            let totalUserCount = 0;
            for (let userId in allUsersData) {
                if (userId !== currentUser.id) {
                    totalUserCount++;
                }
            }

            onlineCount.textContent = onlineUserCount;
            allUsersCount.textContent = totalUserCount;

            if (usersDisplayMode === 'online') {
                // Display only online users
                for (let userId in onlineUsersData) {
                    if (userId !== currentUser.id) {
                        const user = onlineUsersData[userId];
                        displayUser(userId, user, true);
                    }
                }
            } else {
                // Display all users
                for (let userId in allUsersData) {
                    if (userId !== currentUser.id) {
                        const user = allUsersData[userId];
                        const isOnline = onlineUsersData.hasOwnProperty(userId);
                        displayUser(userId, user, isOnline);
                    }
                }
            }
        }

        // Display a single user in the list
        function displayUser(userId, user, isOnline) {
            const usersList = document.getElementById('usersList');
            const userElement = document.createElement('div');
            userElement.className = isOnline ? 'user-item online' : 'user-item offline';
            userElement.style.cursor = 'pointer';
            userElement.setAttribute('data-user-id', userId);

            const statusClass = isOnline ? 'online' : 'offline';
            userElement.innerHTML = `
                <div class="user-avatar">${user.avatar || 'ğŸ˜€'}</div>
                <div class="user-name">${user.username || 'Unknown'}</div>
                <div class="user-status-indicator ${statusClass}"></div>
            `;

            // Add click event to view profile
            userElement.addEventListener('click', (e) => {
                e.preventDefault();
                viewUserProfile(userId, user);
            });

            // Add touch event for mobile
            userElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                viewUserProfile(userId, user);
            });

            usersList.appendChild(userElement);
        }

        // Listen for messages
        let messagesListener = null;

        function updateMessagesListener() {
            // Remove old listener
            if (messagesListener) {
                database.ref('messages').off('value', messagesListener);
                database.ref('privateMessages').off('value', messagesListener);
            }

            const messagesArea = document.getElementById('messagesArea');

            if (chatMode === 'public') {
                messagesListener = database.ref('messages').on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    const messagesWithIds = Object.keys(messages).map(id => ({
                        ...messages[id],
                        messageId: id
                    }));
                    displayMessages(messagesWithIds, messagesArea);
                });
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagesListener = database.ref('privateMessages/' + chatId).on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    const messagesWithIds = Object.keys(messages).map(id => ({
                        ...messages[id],
                        messageId: id
                    }));
                    displayMessages(messagesWithIds, messagesArea);
                });
            }
        }

        function displayMessages(messagesList, messagesArea) {
            console.log('displayMessages called with', messagesList.length, 'messages');
            messagesList = messagesList.sort((a, b) => {
                const aTime = a.timestamp || 0;
                const bTime = b.timestamp || 0;
                return aTime - bTime;
            });

            if (messagesList.length === 0) {
                const emptyText = chatMode === 'private'
                    ? `Start chatting with ${selectedUser.username}!`
                    : 'Start chatting with others!';
                messagesArea.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ğŸ’¬</div>
                        <p>${emptyText}</p>
                    </div>
                `;
                return;
            }

            // Check for new messages and play notification sound + show browser notification
            try {
                const currentMessageIds = new Set(messagesList.map(msg => msg.messageId).filter(id => id));
                let newMessagesFromOthers = [];

                for (const msg of messagesList) {
                    if (msg && msg.messageId && !previousMessageIds.has(msg.messageId)) {
                        const msgUserId = msg.userId || 'unknown';
                        if (msgUserId !== currentUser.id) {
                            newMessagesFromOthers.push(msg);
                        }
                    }
                }

                if (newMessagesFromOthers.length > 0 && previousMessageIds.size > 0) {
                    playNotificationSound();

                    // Visual notification flash (fallback for mobile)
                    flashNotification();

                    // Show browser notification for the latest new message
                    const latestMsg = newMessagesFromOthers[newMessagesFromOthers.length - 1];
                    const username = latestMsg.username || 'Unknown User';
                    const avatar = latestMsg.avatar || 'ğŸ˜€';
                    let text = latestMsg.text || '';
                    if (latestMsg.type === 'image') {
                        text = 'ğŸ“· Image';
                    } else if (latestMsg.type === 'gift' && latestMsg.gift) {
                        text = `${latestMsg.gift.emoji} Sent a ${latestMsg.gift.name}`;
                    }
                    showBrowserNotification(username, text, avatar);
                }

                previousMessageIds = currentMessageIds;
            } catch (error) {
                console.error('Error in notification detection:', error);
            }

            try {
                console.log('Rendering', messagesList.length, 'messages...');

                // Store image messages for modal viewing
                currentImageMessages = {};
                messagesList.forEach(msg => {
                    if (msg && msg.messageId && msg.type === 'image' && msg.imageData) {
                        currentImageMessages[msg.messageId] = msg;
                    }
                });

                messagesArea.innerHTML = messagesList.map(msg => {
                // Skip messages with missing critical data (text, image, or gift)
                if (!msg || !msg.messageId || (!msg.text && !msg.imageData && !msg.gift)) {
                    console.warn('Skipping invalid message:', msg);
                    return '';
                }

                // Provide defaults for missing properties
                const userId = msg.userId || 'unknown';
                const username = msg.username || 'Unknown User';
                const avatar = msg.avatar || 'ğŸ˜€';
                const timestamp = msg.timestamp || Date.now();

                const isOwn = userId === currentUser.id;
                const messageClass = isOwn ? 'message own' : 'message';
                const editButton = isOwn && msg.type !== 'image' ? `<button class="edit-msg-btn" onclick="startEditMessage('${msg.messageId}')" title="Edit message">âœï¸</button>` : '';
                const deleteButton = isOwn ? `<button class="delete-msg-btn" onclick="deleteMessage('${msg.messageId}')" title="Delete message">ğŸ—‘ï¸</button>` : '';
                const editedLabel = msg.edited ? '<span class="edited-label">(edited)</span>' : '';

                // Build reactions display
                let reactionsHtml = '';
                if (msg.reactions) {
                    const reactionCounts = {};
                    for (let userId in msg.reactions) {
                        const emoji = msg.reactions[userId];
                        reactionCounts[emoji] = (reactionCounts[emoji] || 0) + 1;
                    }

                    reactionsHtml = '<div class="message-reactions">';
                    for (let emoji in reactionCounts) {
                        const count = reactionCounts[emoji];
                        const hasReacted = msg.reactions[currentUser.id] === emoji;
                        const reactionClass = hasReacted ? 'reaction-badge active' : 'reaction-badge';
                        reactionsHtml += `<span class="${reactionClass}" onclick="toggleReaction('${msg.messageId}', '${emoji}')">${emoji} ${count}</span>`;
                    }
                    reactionsHtml += '</div>';
                }

                // Build read receipt display
                let readReceiptHtml = '';
                if (isOwn && msg.readBy) {
                    const readByCount = Object.keys(msg.readBy).filter(id => id !== currentUser.id).length;
                    if (chatMode === 'private' && selectedUser) {
                        // Private chat: show checkmark if other person read it
                        const isReadByOther = msg.readBy[selectedUser.id];
                        if (isReadByOther) {
                            readReceiptHtml = '<span class="read-receipt read" title="Read">âœ“âœ“</span>';
                        } else {
                            readReceiptHtml = '<span class="read-receipt delivered" title="Delivered">âœ“</span>';
                        }
                    } else if (chatMode === 'public') {
                        // Public chat: show count if read by others
                        if (readByCount > 0) {
                            readReceiptHtml = `<span class="read-receipt read" title="Read by ${readByCount} ${readByCount === 1 ? 'person' : 'people'}">âœ“âœ“</span>`;
                        } else {
                            readReceiptHtml = '<span class="read-receipt delivered" title="Delivered">âœ“</span>';
                        }
                    }
                }

                // Build message content (text, image, or gift)
                let messageContent = '';
                if (msg.type === 'gift' && msg.gift) {
                    messageContent = `
                        <div class="gift-message">
                            <div class="gift-box">
                                <div class="gift-emoji-large">${msg.gift.emoji}</div>
                                <div class="gift-label">${msg.gift.name}</div>
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'image' && msg.imageData) {
                    messageContent = `
                        <div class="image-message">
                            <img src="${msg.imageData}" alt="${escapeHtml(msg.imageName || 'image')}" class="message-image" onclick="openImageModal('${msg.messageId}')">
                            <div class="image-name">${escapeHtml(msg.imageName || 'image.jpg')}</div>
                        </div>
                    `;
                } else {
                    messageContent = `<span class="message-text" data-original-text="${escapeHtml(msg.text)}">${escapeHtml(msg.text)} ${editedLabel}</span>`;
                }

                return `
                    <div class="${messageClass}" data-message-id="${msg.messageId}">
                        <div class="message-avatar">${avatar}</div>
                        <div class="message-content">
                            <div class="message-header">${username}</div>
                            <div class="message-bubble">
                                ${messageContent}
                                <div class="message-actions" style="display: none;">
                                    <button class="react-msg-btn" onclick="showReactionPicker('${msg.messageId}')" title="Add reaction">ğŸ˜Š</button>
                                    ${editButton}
                                    ${deleteButton}
                                </div>
                            </div>
                            ${reactionsHtml}
                            <div class="message-time">${formatTime(timestamp)} ${readReceiptHtml}</div>
                        </div>
                    </div>
                `;
                }).filter(html => html !== '').join('');

                console.log('Messages rendered successfully');

                // Add context menu (right-click) listeners
                document.querySelectorAll('.message').forEach(messageEl => {
                messageEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();

                    // Hide all other action buttons first
                    document.querySelectorAll('.message-actions').forEach(actions => {
                        actions.style.display = 'none';
                    });

                    // Show actions for this message
                    const actions = messageEl.querySelector('.message-actions');
                    if (actions) {
                        actions.style.display = 'flex';
                    }
                });

                // For mobile: long press to show actions
                let pressTimer;
                messageEl.addEventListener('touchstart', (e) => {
                    pressTimer = setTimeout(() => {
                        // Hide all other action buttons first
                        document.querySelectorAll('.message-actions').forEach(actions => {
                            actions.style.display = 'none';
                        });

                        // Show actions for this message
                        const actions = messageEl.querySelector('.message-actions');
                        if (actions) {
                            actions.style.display = 'flex';
                        }
                    }, 500);
                });

                messageEl.addEventListener('touchend', () => {
                    clearTimeout(pressTimer);
                });

                messageEl.addEventListener('touchmove', () => {
                    clearTimeout(pressTimer);
                });
            });

                messagesArea.scrollTop = messagesArea.scrollHeight;

                // Setup Intersection Observer for read receipts
                setupReadReceiptObserver();
            } catch (error) {
                console.error('Error in message display:', error);
                console.error('Error details:', error.message, error.stack);
                messagesArea.innerHTML = '<div class="empty-state"><div class="empty-icon">âš ï¸</div><p>Error loading messages. Check console for details.</p></div>';
            }
        }

        // Read Receipt Observer
        let readReceiptObserver = null;
        let markedAsReadMessages = new Set(); // Track messages already marked as read

        function setupReadReceiptObserver() {
            // Disconnect previous observer
            if (readReceiptObserver) {
                readReceiptObserver.disconnect();
            }

            // Create new observer
            readReceiptObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const messageId = entry.target.getAttribute('data-message-id');
                        const messageElement = entry.target;

                        // Check if this is someone else's message
                        const isOwnMessage = messageElement.classList.contains('own');
                        if (!isOwnMessage && messageId) {
                            markMessageAsRead(messageId);
                        }
                    }
                });
            }, {
                root: document.getElementById('messagesArea'),
                threshold: 0.5 // Message must be 50% visible
            });

            // Observe all message elements
            document.querySelectorAll('.message').forEach(messageEl => {
                readReceiptObserver.observe(messageEl);
            });
        }

        function markMessageAsRead(messageId) {
            // Don't mark the same message twice
            if (markedAsReadMessages.has(messageId)) {
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/readBy/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/readBy/' + currentUser.id;
            } else {
                return;
            }

            // Check if already marked as read in Firebase before updating
            database.ref(messagePath).once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        // Only mark if not already marked
                        markedAsReadMessages.add(messageId);
                        return database.ref(messagePath).set(Date.now());
                    }
                })
                .catch(error => {
                    console.error('Error marking message as read:', error);
                });
        }

        function getChatId(userId1, userId2) {
            return [userId1, userId2].sort().join('_');
        }

        updateMessagesListener();

        // Hide message actions when clicking outside (add once globally)
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.message') && !e.target.closest('.message-actions')) {
                document.querySelectorAll('.message-actions').forEach(actions => {
                    actions.style.display = 'none';
                });
            }
        });

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const text = messageInput.value.trim();

            if (!text) return;

            const message = {
                userId: currentUser.id,
                username: currentUser.username,
                avatar: currentUser.avatar,
                text: text,
                timestamp: Date.now()
            };

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages';
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId;
            } else {
                return;
            }

            database.ref(messagePath).push(message)
                .then(() => {
                    messageInput.value = '';
                    messageInput.focus();
                })
                .catch(error => {
                    alert('Error sending message: ' + error.message);
                });
        }

        // Image upload functionality
        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            imageInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                console.log('Image file selected:', file.name, 'Size:', file.size, 'Type:', file.type);

                // Check file size (max 10MB for images/GIFs)
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxSize) {
                    alert('Image/GIF file is too large! Maximum size is 10MB.');
                    imageInput.value = '';
                    return;
                }

                // Check if it's an image
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    imageInput.value = '';
                    return;
                }

                const messageInput = document.getElementById('messageInput');
                const originalPlaceholder = messageInput.placeholder;

                try {
                    console.log('Processing image...');

                    // Show processing indicator
                    messageInput.placeholder = 'Processing image...';
                    messageInput.disabled = true;

                    // Convert image to base64
                    const reader = new FileReader();

                    reader.onload = async function(event) {
                        try {
                            const base64Image = event.target.result;
                            console.log('Image converted to base64');

                            // Send image message
                            const message = {
                                userId: currentUser.id,
                                username: currentUser.username,
                                avatar: currentUser.avatar,
                                imageData: base64Image,
                                imageName: file.name,
                                timestamp: Date.now(),
                                type: 'image'
                            };

                            let messagePath;
                            if (chatMode === 'public') {
                                messagePath = 'messages';
                            } else if (chatMode === 'private' && selectedUser) {
                                const chatId = getChatId(currentUser.id, selectedUser.id);
                                messagePath = 'privateMessages/' + chatId;
                            } else {
                                messageInput.placeholder = originalPlaceholder;
                                messageInput.disabled = false;
                                imageInput.value = '';
                                return;
                            }

                            console.log('Sending image message to:', messagePath);
                            await database.ref(messagePath).push(message);
                            console.log('Image message sent successfully!');

                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            imageInput.value = '';
                        } catch (error) {
                            console.error('Error sending image message:', error);
                            alert('Error sending image: ' + error.message);
                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            imageInput.value = '';
                        }
                    };

                    reader.onerror = function(error) {
                        console.error('Error reading file:', error);
                        alert('Error reading image file');
                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                        imageInput.value = '';
                    };

                    reader.readAsDataURL(file);

                } catch (error) {
                    console.error('Error processing image:', error);
                    alert('Error processing image: ' + error.message);
                    messageInput.placeholder = originalPlaceholder;
                    messageInput.disabled = false;
                    imageInput.value = '';
                }
            });
        }

        function deleteMessage(messageId) {
            if (!confirm('Are you sure you want to delete this message?')) {
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId;
            } else {
                return;
            }

            database.ref(messagePath).remove()
                .then(() => {
                    console.log('Message deleted successfully');
                })
                .catch(error => {
                    alert('Error deleting message: ' + error.message);
                });
        }

        function startEditMessage(messageId) {
            // Find the message element
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const messageBubble = messageElement.querySelector('.message-bubble');
            const messageTextSpan = messageElement.querySelector('.message-text');
            const originalText = messageTextSpan.getAttribute('data-original-text');

            // Replace message content with edit input
            messageBubble.innerHTML = `
                <input type="text" class="edit-message-input" value="${originalText}" maxlength="500" />
                <div class="edit-message-actions">
                    <button class="save-edit-btn" onclick="saveEditMessage('${messageId}')" title="Save">âœ“</button>
                    <button class="cancel-edit-btn" onclick="cancelEditMessage('${messageId}')" title="Cancel">âœ•</button>
                </div>
            `;

            // Focus the input
            const input = messageBubble.querySelector('.edit-message-input');
            input.focus();
            input.select();

            // Allow saving with Enter key
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEditMessage(messageId);
                } else if (e.key === 'Escape') {
                    cancelEditMessage(messageId);
                }
            });
        }

        function saveEditMessage(messageId) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const input = messageElement.querySelector('.edit-message-input');
            const newText = input.value.trim();

            if (!newText) {
                alert('Message cannot be empty!');
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId;
            } else {
                return;
            }

            database.ref(messagePath).update({
                text: newText,
                edited: true,
                editedAt: Date.now()
            })
            .then(() => {
                console.log('Message edited successfully');
            })
            .catch(error => {
                alert('Error editing message: ' + error.message);
            });
        }

        function cancelEditMessage(messageId) {
            // Just trigger a re-render by doing nothing - Firebase listener will restore original
            console.log('Edit cancelled');
        }

        // Reaction functions
        const quickReactions = ['â¤ï¸', 'ğŸ‘', 'ğŸ˜‚', 'ğŸ˜®', 'ğŸ˜¢', 'ğŸ™', 'ğŸ‰', 'ğŸ”¥'];

        function showReactionPicker(messageId) {
            // Hide all reaction pickers first
            document.querySelectorAll('.reaction-picker').forEach(picker => picker.remove());

            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;

            const messageBubble = messageEl.querySelector('.message-bubble');

            // Create reaction picker
            const picker = document.createElement('div');
            picker.className = 'reaction-picker';
            picker.innerHTML = quickReactions.map(emoji =>
                `<button class="reaction-option" onclick="addReaction('${messageId}', '${emoji}')">${emoji}</button>`
            ).join('');

            messageBubble.appendChild(picker);

            // Close picker when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePickerHandler(e) {
                    if (!picker.contains(e.target)) {
                        picker.remove();
                        document.removeEventListener('click', closePickerHandler);
                    }
                }, { once: false });
            }, 100);
        }

        function addReaction(messageId, emoji) {
            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/reactions/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/reactions/' + currentUser.id;
            } else {
                return;
            }

            database.ref(messagePath).set(emoji)
                .then(() => {
                    // Remove picker
                    document.querySelectorAll('.reaction-picker').forEach(picker => picker.remove());
                })
                .catch(error => {
                    alert('Error adding reaction: ' + error.message);
                });
        }

        function toggleReaction(messageId, emoji) {
            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/reactions/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/reactions/' + currentUser.id;
            } else {
                return;
            }

            // Check if user already reacted with this emoji
            database.ref(messagePath).once('value')
                .then(snapshot => {
                    if (snapshot.val() === emoji) {
                        // Remove reaction
                        return database.ref(messagePath).remove();
                    } else {
                        // Change to this reaction
                        return database.ref(messagePath).set(emoji);
                    }
                })
                .catch(error => {
                    alert('Error toggling reaction: ' + error.message);
                });
        }

        function startPrivateChat(userId, user) {
            console.log('startPrivateChat called with:', userId, user);
            chatMode = 'private';
            selectedUser = { id: userId, ...user };

            console.log('Chat mode set to:', chatMode, 'Selected user:', selectedUser);

            document.getElementById('chatMode').textContent = `Chatting with ${user.username}`;
            document.getElementById('backBtn').style.display = 'block';

            updateMessagesListener();
            updateTypingListener();
            updateCallButtonVisibility();

            console.log('Private chat started successfully');
        }

        function backToPublicChat() {
            chatMode = 'public';
            selectedUser = null;

            document.getElementById('chatMode').textContent = 'Public Chat';
            document.getElementById('backBtn').style.display = 'none';

            updateMessagesListener();
            updateTypingListener();
            updateCallButtonVisibility();
        }

        // Typing Indicator Logic
        let typingTimeout;
        let isTyping = false;

        function setTypingStatus(typing) {
            let typingPath;
            if (chatMode === 'public') {
                typingPath = 'typing/public/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                typingPath = 'typing/private/' + chatId + '/' + currentUser.id;
            } else {
                return;
            }

            if (typing) {
                database.ref(typingPath).set({
                    username: currentUser.username,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            } else {
                database.ref(typingPath).remove();
            }
        }

        // Listen for typing status
        function updateTypingListener() {
            // Remove old listeners
            database.ref('typing/public').off();
            database.ref('typing/private').off();

            if (chatMode === 'public') {
                database.ref('typing/public').on('value', (snapshot) => {
                    displayTypingIndicator(snapshot.val());
                });
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                database.ref('typing/private/' + chatId).on('value', (snapshot) => {
                    displayTypingIndicator(snapshot.val());
                });
            }
        }

        function displayTypingIndicator(typingUsers) {
            const typingIndicator = document.getElementById('typingIndicator');
            const typingText = document.getElementById('typingText');

            if (!typingUsers) {
                typingIndicator.style.display = 'none';
                return;
            }

            const usersTyping = [];
            for (let userId in typingUsers) {
                if (userId !== currentUser.id) {
                    usersTyping.push(typingUsers[userId].username);
                }
            }

            if (usersTyping.length === 0) {
                typingIndicator.style.display = 'none';
            } else if (usersTyping.length === 1) {
                typingText.textContent = usersTyping[0] + ' is typing';
                typingIndicator.style.display = 'flex';
            } else if (usersTyping.length === 2) {
                typingText.textContent = usersTyping[0] + ' and ' + usersTyping[1] + ' are typing';
                typingIndicator.style.display = 'flex';
            } else {
                typingText.textContent = usersTyping.length + ' people are typing';
                typingIndicator.style.display = 'flex';
            }
        }

        updateTypingListener();

        const messageInput = document.getElementById('messageInput');

        messageInput.addEventListener('input', () => {
            // Initialize audio context on first input (mobile-friendly)
            initAudioContext();

            if (!isTyping) {
                isTyping = true;
                setTypingStatus(true);
            }

            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                isTyping = false;
                setTypingStatus(false);
            }, 2000);
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
                clearTimeout(typingTimeout);
                isTyping = false;
                setTypingStatus(false);
            }
        });

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                onlineUserRef.remove();
                localStorage.removeItem('chatapp_user');
                window.location.href = 'index.html';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;

            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }

        // Emoji Picker Functionality
        const emojiCategories = {
            smileys: ['ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ¥²', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥', 'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜¶â€ğŸŒ«ï¸', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ¥¸', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§'],
            gestures: ['ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ', 'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸', 'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'ğŸ’ª', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ¦µ', 'ğŸ¦¶', 'ğŸ‘‚', 'ğŸ¦»', 'ğŸ‘ƒ', 'ğŸ§ ', 'ğŸ«€', 'ğŸ«', 'ğŸ¦·', 'ğŸ¦´', 'ğŸ‘€', 'ğŸ‘ï¸', 'ğŸ‘…', 'ğŸ‘„', 'ğŸ’‹'],
            hearts: ['â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ¤', 'ğŸ¤', 'ğŸ’”', 'â¤ï¸â€ğŸ”¥', 'â¤ï¸â€ğŸ©¹', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ğŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ğŸ”¯', 'ğŸ•', 'â˜¯ï¸', 'â˜¦ï¸', 'ğŸ›', 'â›', 'â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™', 'â™', 'â™', 'â™‘', 'â™’', 'â™“'],
            animals: ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ½', 'ğŸ¸', 'ğŸµ', 'ğŸ™ˆ', 'ğŸ™‰', 'ğŸ™Š', 'ğŸ’', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¤', 'ğŸ£', 'ğŸ¥', 'ğŸ¦†', 'ğŸ¦…', 'ğŸ¦‰', 'ğŸ¦‡', 'ğŸº', 'ğŸ—', 'ğŸ´', 'ğŸ¦„', 'ğŸ', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ', 'ğŸœ', 'ğŸ¦Ÿ', 'ğŸ¦—', 'ğŸ•·ï¸', 'ğŸ•¸ï¸', 'ğŸ¦‚', 'ğŸ¢', 'ğŸ', 'ğŸ¦', 'ğŸ¦–', 'ğŸ¦•', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦', 'ğŸ¦', 'ğŸ¦€', 'ğŸ¡', 'ğŸ ', 'ğŸŸ', 'ğŸ¬', 'ğŸ³', 'ğŸ‹', 'ğŸ¦ˆ', 'ğŸŠ', 'ğŸ…', 'ğŸ†', 'ğŸ¦“', 'ğŸ¦', 'ğŸ¦§', 'ğŸ˜', 'ğŸ¦›', 'ğŸ¦', 'ğŸª', 'ğŸ«', 'ğŸ¦’', 'ğŸ¦˜', 'ğŸƒ', 'ğŸ‚', 'ğŸ„', 'ğŸ', 'ğŸ–', 'ğŸ', 'ğŸ‘', 'ğŸ¦™', 'ğŸ', 'ğŸ¦Œ', 'ğŸ•', 'ğŸ©', 'ğŸ¦®', 'ğŸ•â€ğŸ¦º', 'ğŸˆ', 'ğŸˆâ€â¬›', 'ğŸ“', 'ğŸ¦ƒ', 'ğŸ¦š', 'ğŸ¦œ', 'ğŸ¦¢', 'ğŸ¦©', 'ğŸ•Šï¸', 'ğŸ‡', 'ğŸ¦', 'ğŸ¦¨', 'ğŸ¦¡', 'ğŸ¦¦', 'ğŸ¦¥', 'ğŸ', 'ğŸ€', 'ğŸ¿ï¸', 'ğŸ¦”'],
            food: ['ğŸ•', 'ğŸ”', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ§ˆ', 'ğŸ¥“', 'ğŸ¥š', 'ğŸ³', 'ğŸ§‡', 'ğŸ¥', 'ğŸ§ˆ', 'ğŸ', 'ğŸ¥', 'ğŸ¥¨', 'ğŸ¥¯', 'ğŸ¥–', 'ğŸ§€', 'ğŸ¥—', 'ğŸ¥™', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸŒ¯', 'ğŸ«”', 'ğŸ¥«', 'ğŸ–', 'ğŸ—', 'ğŸ¥©', 'ğŸ ', 'ğŸ¥Ÿ', 'ğŸ¥ ', 'ğŸ¥¡', 'ğŸ±', 'ğŸ˜', 'ğŸ™', 'ğŸš', 'ğŸ›', 'ğŸœ', 'ğŸ¦ª', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¥®', 'ğŸ¢', 'ğŸ§†', 'ğŸ¥˜', 'ğŸ²', 'ğŸ«•', 'ğŸ', 'ğŸ¥§', 'ğŸ°', 'ğŸ‚', 'ğŸ§', 'ğŸ®', 'ğŸ­', 'ğŸ¬', 'ğŸ«', 'ğŸ¿', 'ğŸ©', 'ğŸª', 'ğŸŒ°', 'ğŸ¥œ', 'ğŸ¯', 'ğŸ¥›', 'ğŸ¼', 'â˜•', 'ğŸµ', 'ğŸ§ƒ', 'ğŸ¥¤', 'ğŸ¶', 'ğŸº', 'ğŸ»', 'ğŸ¥‚', 'ğŸ·', 'ğŸ¥ƒ', 'ğŸ¸', 'ğŸ¹', 'ğŸ§‰', 'ğŸ¾', 'ğŸ§Š', 'ğŸ¥„', 'ğŸ´', 'ğŸ½ï¸', 'ğŸ¥£', 'ğŸ¥¡', 'ğŸ¥¢', 'ğŸ§‚'],
            activities: ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¥', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ±', 'ğŸª€', 'ğŸ“', 'ğŸ¸', 'ğŸ’', 'ğŸ‘', 'ğŸ¥', 'ğŸ', 'ğŸ¥…', 'â›³', 'ğŸª', 'ğŸ¹', 'ğŸ£', 'ğŸ¤¿', 'ğŸ¥Š', 'ğŸ¥‹', 'ğŸ½', 'ğŸ›¹', 'ğŸ›¼', 'ğŸ›·', 'â›¸ï¸', 'ğŸ¥Œ', 'ğŸ¿', 'â›·ï¸', 'ğŸ‚', 'ğŸª‚', 'ğŸ‹ï¸', 'ğŸ¤¼', 'ğŸ¤¸', 'ğŸ¤¾', 'ğŸŒï¸', 'ğŸ‡', 'ğŸ§˜', 'ğŸŠ', 'ğŸ¤½', 'ğŸš£', 'ğŸ§—', 'ğŸšµ', 'ğŸš´', 'ğŸ†', 'ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ…', 'ğŸ–ï¸', 'ğŸ—ï¸', 'ğŸ«', 'ğŸŸï¸', 'ğŸª', 'ğŸ­', 'ğŸ¨', 'ğŸ¬', 'ğŸ¤', 'ğŸ§', 'ğŸ¼', 'ğŸ¹', 'ğŸ¥', 'ğŸ·', 'ğŸº', 'ğŸ¸', 'ğŸª•', 'ğŸ»', 'ğŸ²', 'â™Ÿï¸', 'ğŸ¯', 'ğŸ³', 'ğŸ®', 'ğŸ°', 'ğŸ§©'],
            objects: ['ğŸ’¡', 'ğŸ”¦', 'ğŸ•¯ï¸', 'ğŸª”', 'ğŸ§¯', 'ğŸ›¢ï¸', 'ğŸ’¸', 'ğŸ’µ', 'ğŸ’´', 'ğŸ’¶', 'ğŸ’·', 'ğŸª™', 'ğŸ’°', 'ğŸ’³', 'ğŸ’', 'âš–ï¸', 'ğŸªœ', 'ğŸ§°', 'ğŸª›', 'ğŸ”§', 'ğŸ”¨', 'âš’ï¸', 'ğŸ› ï¸', 'â›ï¸', 'ğŸªš', 'ğŸ”©', 'âš™ï¸', 'ğŸª¤', 'ğŸ§±', 'â›“ï¸', 'ğŸ§²', 'ğŸ”«', 'ğŸ’£', 'ğŸ§¨', 'ğŸª“', 'ğŸ”ª', 'ğŸ—¡ï¸', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸš¬', 'âš°ï¸', 'ğŸª¦', 'âš±ï¸', 'ğŸº', 'ğŸ”®', 'ğŸ“¿', 'ğŸ§¿', 'ğŸ’ˆ', 'âš—ï¸', 'ğŸ”­', 'ğŸ”¬', 'ğŸ•³ï¸', 'ğŸ©¹', 'ğŸ©º', 'ğŸ’Š', 'ğŸ’‰', 'ğŸ©¸', 'ğŸ§¬', 'ğŸ¦ ', 'ğŸ§«', 'ğŸ§ª', 'ğŸŒ¡ï¸', 'ğŸ§¹', 'ğŸª ', 'ğŸ§º', 'ğŸ§»', 'ğŸš½', 'ğŸš°', 'ğŸš¿', 'ğŸ›', 'ğŸ›€', 'ğŸ§¼', 'ğŸª’', 'ğŸ§½', 'ğŸª£', 'ğŸ§´', 'ğŸ§·', 'ğŸ§¹', 'ğŸ§º', 'ğŸ§»', 'ğŸª£']
        };

        let currentCategory = 'smileys';

        function loadEmojis(category) {
            const emojiGrid = document.getElementById('emojiGrid');
            emojiGrid.innerHTML = '';
            const emojis = emojiCategories[category] || emojiCategories.smileys;

            emojis.forEach(emoji => {
                const emojiElement = document.createElement('span');
                emojiElement.className = 'emoji-item';
                emojiElement.textContent = emoji;
                emojiElement.addEventListener('click', () => insertEmoji(emoji));
                emojiElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    insertEmoji(emoji);
                });
                emojiGrid.appendChild(emojiElement);
            });
        }

        function toggleEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            if (picker.style.display === 'none') {
                picker.style.display = 'block';
                loadEmojis(currentCategory);
            } else {
                picker.style.display = 'none';
            }
        }

        function insertEmoji(emoji) {
            const input = document.getElementById('messageInput');
            const cursorPos = input.selectionStart;
            const textBefore = input.value.substring(0, cursorPos);
            const textAfter = input.value.substring(cursorPos);
            input.value = textBefore + emoji + textAfter;
            input.focus();
            input.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
        }

        // Emoji category switching
        document.addEventListener('DOMContentLoaded', function() {
            const categoryButtons = document.querySelectorAll('.emoji-category');
            categoryButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    categoryButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentCategory = this.getAttribute('data-category');
                    loadEmojis(currentCategory);
                });
            });

            // Close emoji picker when clicking outside
            document.addEventListener('click', function(e) {
                const picker = document.getElementById('emojiPicker');
                const emojiBtn = document.getElementById('emojiBtn');
                if (picker.style.display === 'block' && !picker.contains(e.target) && e.target !== emojiBtn) {
                    picker.style.display = 'none';
                }
            });
        });

        // Profile Settings Functions
        let selectedProfileAvatar = currentUser.avatar;

        function openProfileSettings() {
            const modal = document.getElementById('profileModal');
            const currentAvatarDisplay = document.getElementById('currentAvatarDisplay');
            const newUsernameInput = document.getElementById('newUsername');

            // Set current values
            currentAvatarDisplay.textContent = currentUser.avatar;
            selectedProfileAvatar = currentUser.avatar;
            newUsernameInput.value = currentUser.username;

            // Highlight current avatar
            const avatarOptions = document.querySelectorAll('#profileAvatarSelector .avatar-option');
            avatarOptions.forEach(option => {
                const emoji = option.getAttribute('data-avatar');
                if (emoji === currentUser.avatar) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });

            // Setup avatar selection
            avatarOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const emoji = this.getAttribute('data-avatar');
                    selectedProfileAvatar = emoji;
                    currentAvatarDisplay.textContent = emoji;

                    avatarOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            modal.style.display = 'flex';
        }

        function closeProfileSettings() {
            const modal = document.getElementById('profileModal');
            const profileMessage = document.getElementById('profileMessage');

            modal.style.display = 'none';
            profileMessage.style.display = 'none';

            // Clear password fields
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmNewPassword').value = '';
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('profileModal');
            if (e.target === modal) {
                closeProfileSettings();
            }
        });

        function showProfileMessage(message, type) {
            const profileMessage = document.getElementById('profileMessage');
            profileMessage.textContent = message;
            profileMessage.className = type;
            profileMessage.style.display = 'block';

            setTimeout(() => {
                profileMessage.style.display = 'none';
            }, 3000);
        }

        async function updateAvatar() {
            if (selectedProfileAvatar === currentUser.avatar) {
                showProfileMessage('No changes made to avatar', 'warning');
                return;
            }

            try {
                // Update in Firebase
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                for (let userId in users) {
                    if (userId === currentUser.id) {
                        await database.ref('users/' + userId).update({
                            avatar: selectedProfileAvatar
                        });
                        break;
                    }
                }

                // Update online status
                await onlineUserRef.update({
                    avatar: selectedProfileAvatar
                });

                // Update local storage and current user
                currentUser.avatar = selectedProfileAvatar;
                localStorage.setItem('chatapp_user', JSON.stringify(currentUser));

                // Update UI
                document.getElementById('currentUserAvatar').textContent = selectedProfileAvatar;

                showProfileMessage('Avatar updated successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error updating avatar: ' + error.message, 'error');
            }
        }

        async function updateUsername() {
            const newUsername = document.getElementById('newUsername').value.trim();

            if (!newUsername || newUsername.length < 3) {
                showProfileMessage('Username must be at least 3 characters', 'warning');
                return;
            }

            if (newUsername === currentUser.username) {
                showProfileMessage('No changes made to username', 'warning');
                return;
            }

            try {
                // Check if username is taken
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                for (let userId in users) {
                    if (userId !== currentUser.id && users[userId].username.toLowerCase() === newUsername.toLowerCase()) {
                        showProfileMessage('Username already taken!', 'error');
                        return;
                    }
                }

                // Update in Firebase
                for (let userId in users) {
                    if (userId === currentUser.id) {
                        await database.ref('users/' + userId).update({
                            username: newUsername
                        });
                        break;
                    }
                }

                // Update online status
                await onlineUserRef.update({
                    username: newUsername
                });

                // Update local storage and current user
                currentUser.username = newUsername;
                localStorage.setItem('chatapp_user', JSON.stringify(currentUser));

                // Update UI
                document.getElementById('currentUsername').textContent = newUsername;

                showProfileMessage('Username updated successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error updating username: ' + error.message, 'error');
            }
        }

        // User Profile View Functions
        let viewedUserData = null;
        let profileButtonsInitialized = false;

        // Initialize profile modal buttons once
        function initializeProfileButtons() {
            if (profileButtonsInitialized) return;

            const closeBtn = document.getElementById('closeUserProfileBtn');
            const chatBtn = document.getElementById('chatWithUserBtn');

            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    console.log('Close button clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    closeUserProfile();
                });
            }

            if (chatBtn) {
                chatBtn.addEventListener('click', function(e) {
                    console.log('=== Send Message button ACTUALLY clicked! ===');
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('viewedUserData:', viewedUserData);
                    chatWithViewedUser();
                });
            }

            profileButtonsInitialized = true;
            console.log('Profile buttons initialized');
        }

        async function viewUserProfile(userId, user) {
            console.log('viewUserProfile called with:', userId, user);
            viewedUserData = { id: userId, ...user };

            // Initialize buttons if not done yet
            initializeProfileButtons();

            const modal = document.getElementById('userProfileModal');
            const avatar = document.getElementById('viewProfileAvatar');
            const username = document.getElementById('viewProfileUsername');
            const joined = document.getElementById('viewProfileJoined');
            const userIdDisplay = document.getElementById('viewProfileId');

            avatar.textContent = user.avatar || 'ğŸ˜€';
            username.textContent = user.username || 'Unknown User';
            userIdDisplay.textContent = userId.substring(0, 8) + '...';

            // Fetch user data from Firebase to get joinedAt
            try {
                const snapshot = await database.ref('users/' + userId).once('value');
                const userData = snapshot.val();

                if (userData && userData.joinedAt) {
                    const joinDate = new Date(userData.joinedAt);
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    joined.textContent = joinDate.toLocaleDateString('en-US', options);
                } else {
                    joined.textContent = 'Recently';
                }
            } catch (error) {
                console.error('Error fetching user data:', error);
                joined.textContent = 'Recently';
            }

            modal.style.display = 'flex';
        }

        function closeUserProfile() {
            const modal = document.getElementById('userProfileModal');
            modal.style.display = 'none';
            viewedUserData = null;
        }

        function chatWithViewedUser() {
            console.log('=== chatWithViewedUser called ===');
            console.log('viewedUserData:', viewedUserData);

            if (!viewedUserData) {
                console.error('ERROR: No viewedUserData available!');
                alert('Error: User data not available. Please try again.');
                return;
            }

            console.log('viewedUserData.id:', viewedUserData.id);
            console.log('viewedUserData.username:', viewedUserData.username);
            console.log('viewedUserData.avatar:', viewedUserData.avatar);

            // Save user data BEFORE closing modal (which sets viewedUserData to null)
            const userId = viewedUserData.id;
            const userForChat = {
                username: viewedUserData.username,
                avatar: viewedUserData.avatar
            };

            console.log('userForChat object:', userForChat);
            console.log('Closing profile modal...');
            closeUserProfile();

            console.log('Calling startPrivateChat with userId:', userId, 'and user:', userForChat);
            startPrivateChat(userId, userForChat);
            console.log('=== chatWithViewedUser finished ===');
        }

        // Close user profile modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('userProfileModal');
            const modalContent = document.querySelector('.user-profile-content');
            if (e.target === modal && !modalContent.contains(e.target)) {
                closeUserProfile();
            }
        });


        // GIF Picker functionality
        const TENOR_API_KEY = 'AIzaSyAyLGdwVFNawJ8km63NMV6p6m0NCCLlGek'; // Public Tenor API key
        let gifPickerOpen = false;

        function toggleGifPicker() {
            const gifPicker = document.getElementById('gifPicker');
            gifPickerOpen = !gifPickerOpen;

            if (gifPickerOpen) {
                gifPicker.style.display = 'block';
                loadTrendingGifs();

                // Setup search
                const searchInput = document.getElementById('gifSearchInput');
                let searchTimeout;

                searchInput.oninput = function() {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const query = searchInput.value.trim();
                        if (query) {
                            searchGifs(query);
                        } else {
                            loadTrendingGifs();
                        }
                    }, 500);
                };

                searchInput.focus();
            } else {
                gifPicker.style.display = 'none';
            }
        }

        // Close GIF picker when clicking outside
        document.addEventListener('click', function(e) {
            const gifPicker = document.getElementById('gifPicker');
            const gifBtn = document.getElementById('gifBtn');
            if (gifPickerOpen && !gifPicker.contains(e.target) && e.target !== gifBtn) {
                toggleGifPicker();
            }
        });

        async function loadTrendingGifs() {
            const gifGrid = document.getElementById('gifGrid');
            gifGrid.innerHTML = '<div class="gif-loading">Loading trending GIFs...</div>';

            try {
                const response = await fetch(`https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&limit=20&media_filter=gif`);
                const data = await response.json();
                displayGifs(data.results);
            } catch (error) {
                console.error('Error loading trending GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Failed to load GIFs. Try again later.</div>';
            }
        }

        async function searchGifs(query) {
            const gifGrid = document.getElementById('gifGrid');
            gifGrid.innerHTML = '<div class="gif-loading">Searching GIFs...</div>';

            try {
                const response = await fetch(`https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(query)}&key=${TENOR_API_KEY}&limit=20&media_filter=gif`);
                const data = await response.json();
                displayGifs(data.results);
            } catch (error) {
                console.error('Error searching GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Failed to search GIFs. Try again.</div>';
            }
        }

        function displayGifs(gifs) {
            const gifGrid = document.getElementById('gifGrid');

            if (!gifs || gifs.length === 0) {
                gifGrid.innerHTML = '<div class="gif-error">No GIFs found</div>';
                return;
            }

            gifGrid.innerHTML = gifs.map(gif => {
                const gifUrl = gif.media_formats.tinygif.url;
                const previewUrl = gif.media_formats.tinygif.url;
                return `<div class="gif-item" onclick='sendGif("${gifUrl}")'>
                    <img src="${previewUrl}" alt="GIF">
                </div>`;
            }).join('');
        }

        async function sendGif(gifUrl) {
            try {
                // Close GIF picker
                toggleGifPicker();

                // Show loading
                const messageInput = document.getElementById('messageInput');
                const originalPlaceholder = messageInput.placeholder;
                messageInput.placeholder = 'Loading GIF...';
                messageInput.disabled = true;

                // Fetch GIF and convert to base64
                const response = await fetch(gifUrl);
                const blob = await response.blob();

                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const base64Image = event.target.result;

                        // Send GIF message
                        const message = {
                            userId: currentUser.id,
                            username: currentUser.username,
                            avatar: currentUser.avatar,
                            imageData: base64Image,
                            imageName: 'animated.gif',
                            timestamp: Date.now(),
                            type: 'image'
                        };

                        let messagePath;
                        if (chatMode === 'public') {
                            messagePath = 'messages';
                        } else if (chatMode === 'private' && selectedUser) {
                            const chatId = getChatId(currentUser.id, selectedUser.id);
                            messagePath = 'privateMessages/' + chatId;
                        } else {
                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            return;
                        }

                        await database.ref(messagePath).push(message);
                        console.log('GIF sent successfully!');

                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                    } catch (error) {
                        console.error('Error sending GIF:', error);
                        alert('Error sending GIF: ' + error.message);
                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                    }
                };

                reader.readAsDataURL(blob);

            } catch (error) {
                console.error('Error loading GIF:', error);
                alert('Error loading GIF: ' + error.message);
                messageInput.placeholder = originalPlaceholder;
                messageInput.disabled = false;
            }
        }

        // Gift Picker functionality
        const gifts = [
            { emoji: 'â¤ï¸', name: 'Heart' },
            { emoji: 'ğŸ’', name: 'Gift Heart' },
            { emoji: 'ğŸŒ¹', name: 'Rose' },
            { emoji: 'ğŸ’', name: 'Bouquet' },
            { emoji: 'ğŸ‚', name: 'Birthday Cake' },
            { emoji: 'ğŸ°', name: 'Cake' },
            { emoji: 'ğŸ', name: 'Gift' },
            { emoji: 'ğŸ†', name: 'Trophy' },
            { emoji: 'ğŸ‘‘', name: 'Crown' },
            { emoji: 'ğŸ’', name: 'Diamond' },
            { emoji: 'â­', name: 'Star' },
            { emoji: 'âœ¨', name: 'Sparkles' },
            { emoji: 'ğŸ‰', name: 'Party Popper' },
            { emoji: 'ğŸŠ', name: 'Confetti Ball' },
            { emoji: 'ğŸŒŸ', name: 'Glowing Star' },
            { emoji: 'ğŸ’–', name: 'Sparkling Heart' },
            { emoji: 'ğŸ”¥', name: 'Fire' },
            { emoji: 'â˜€ï¸', name: 'Sun' },
            { emoji: 'ğŸŒˆ', name: 'Rainbow' },
            { emoji: 'ğŸ¦‹', name: 'Butterfly' }
        ];

        let giftPickerOpen = false;

        function toggleGiftPicker() {
            const giftPicker = document.getElementById('giftPicker');
            giftPickerOpen = !giftPickerOpen;

            if (giftPickerOpen) {
                giftPicker.style.display = 'block';
                loadGifts();
            } else {
                giftPicker.style.display = 'none';
            }
        }

        // Close gift picker when clicking outside
        document.addEventListener('click', function(e) {
            const giftPicker = document.getElementById('giftPicker');
            const giftBtn = document.getElementById('giftBtn');
            if (giftPickerOpen && !giftPicker.contains(e.target) && e.target !== giftBtn) {
                toggleGiftPicker();
            }
        });

        function loadGifts() {
            const giftGrid = document.getElementById('giftGrid');
            giftGrid.innerHTML = '';

            gifts.forEach(gift => {
                const giftItem = document.createElement('div');
                giftItem.className = 'gift-item';
                giftItem.innerHTML = `
                    <div class="gift-emoji">${gift.emoji}</div>
                    <div class="gift-name">${gift.name}</div>
                `;
                giftItem.onclick = () => sendGift(gift);
                giftGrid.appendChild(giftItem);
            });
        }

        async function sendGift(gift) {
            if (!currentUser) {
                alert('You must be logged in to send gifts!');
                return;
            }

            toggleGiftPicker();

            try {
                const message = {
                    userId: currentUser.id,
                    username: currentUser.username,
                    avatar: currentUser.avatar,
                    gift: {
                        emoji: gift.emoji,
                        name: gift.name
                    },
                    timestamp: Date.now(),
                    type: 'gift'
                };

                let messagePath;
                if (chatMode === 'public') {
                    messagePath = 'messages';
                } else if (chatMode === 'private' && selectedUser) {
                    const chatId = getChatId(currentUser.id, selectedUser.id);
                    messagePath = 'privateMessages/' + chatId;
                } else {
                    alert('Cannot send gift. No chat selected.');
                    return;
                }

                await database.ref(messagePath).push(message);
                console.log('Gift sent successfully!');

            } catch (error) {
                console.error('Error sending gift:', error);
                alert('Error sending gift: ' + error.message);
            }
        }

        // Call functionality with WebRTC
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let isMuted = false;
        let isVideoOn = false;
        let callTimer = null;
        let callStartTime = null;
        let currentCallId = null;
        let isCallInitiator = false;

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Show call button only in private chat
        function updateCallButtonVisibility() {
            const callBtn = document.getElementById('callBtn');
            if (chatMode === 'private' && selectedUser) {
                callBtn.style.display = 'block';
            } else {
                callBtn.style.display = 'none';
            }
        }

        // Start a call
        async function startCall() {
            if (!selectedUser) {
                alert('Please select a user to call');
                return;
            }

            try {
                isCallInitiator = true;
                currentCallId = `call_${currentUser.id}_${selectedUser.id}_${Date.now()}`;

                // Show call modal
                document.getElementById('callModal').style.display = 'flex';
                document.getElementById('callAvatar').textContent = selectedUser.avatar;
                document.getElementById('callUsername').textContent = selectedUser.username;
                document.getElementById('callStatus').textContent = 'Calling...';

                // Get local audio stream
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

                // Create peer connection
                peerConnection = new RTCPeerConnection(configuration);

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle incoming tracks
                peerConnection.ontrack = (event) => {
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        const audioElement = new Audio();
                        audioElement.srcObject = remoteStream;
                        audioElement.play();
                    }
                    event.streams[0].getTracks().forEach(track => {
                        remoteStream.addTrack(track);
                    });
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        database.ref(`calls/${currentCallId}/candidates/${currentUser.id}`).push({
                            candidate: event.candidate.toJSON()
                        });
                    }
                };

                // Create and send offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Save call to Firebase
                await database.ref(`calls/${currentCallId}`).set({
                    callerId: currentUser.id,
                    callerName: currentUser.username,
                    callerAvatar: currentUser.avatar,
                    receiverId: selectedUser.id,
                    offer: {
                        type: offer.type,
                        sdp: offer.sdp
                    },
                    status: 'ringing',
                    timestamp: Date.now()
                });

                // Listen for answer
                database.ref(`calls/${currentCallId}/answer`).on('value', async (snapshot) => {
                    const answer = snapshot.val();
                    if (answer && peerConnection.signalingState === 'have-local-offer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    }
                });

                // Listen for remote ICE candidates
                database.ref(`calls/${currentCallId}/candidates/${selectedUser.id}`).on('child_added', async (snapshot) => {
                    const candidate = snapshot.val().candidate;
                    if (peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                });

                // Listen for call status
                database.ref(`calls/${currentCallId}/status`).on('value', (snapshot) => {
                    const status = snapshot.val();
                    if (status === 'accepted') {
                        startCallTimer();
                        document.getElementById('callStatus').textContent = 'Connected';
                        document.getElementById('muteBtn').style.display = 'block';
                    } else if (status === 'rejected' || status === 'ended') {
                        endCall();
                    }
                });

            } catch (error) {
                console.error('Error starting call:', error);
                alert('Error starting call: ' + error.message);
                endCall();
            }
        }

        // Listen for incoming calls
        database.ref('calls').on('child_added', async (snapshot) => {
            const call = snapshot.val();
            const callId = snapshot.key;

            if (call.receiverId === currentUser.id && call.status === 'ringing') {
                currentCallId = callId;
                isCallInitiator = false;

                // Show incoming call modal
                document.getElementById('incomingCallModal').style.display = 'flex';
                document.getElementById('incomingCallAvatar').textContent = call.callerAvatar;
                document.getElementById('incomingCallUsername').textContent = call.callerName;

                // Play ringtone
                playNotificationSound();
            }
        });

        // Accept call
        async function acceptCall() {
            try {
                document.getElementById('incomingCallModal').style.display = 'none';
                document.getElementById('callModal').style.display = 'flex';

                const callSnapshot = await database.ref(`calls/${currentCallId}`).once('value');
                const call = callSnapshot.val();

                document.getElementById('callAvatar').textContent = call.callerAvatar;
                document.getElementById('callUsername').textContent = call.callerName;
                document.getElementById('callStatus').textContent = 'Connecting...';

                // Get local audio stream
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

                // Create peer connection
                peerConnection = new RTCPeerConnection(configuration);

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle incoming tracks
                peerConnection.ontrack = (event) => {
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        const audioElement = new Audio();
                        audioElement.srcObject = remoteStream;
                        audioElement.play();
                    }
                    event.streams[0].getTracks().forEach(track => {
                        remoteStream.addTrack(track);
                    });
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        database.ref(`calls/${currentCallId}/candidates/${currentUser.id}`).push({
                            candidate: event.candidate.toJSON()
                        });
                    }
                };

                // Set remote description
                await peerConnection.setRemoteDescription(new RTCSessionDescription(call.offer));

                // Create and send answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                await database.ref(`calls/${currentCallId}/answer`).set({
                    type: answer.type,
                    sdp: answer.sdp
                });

                // Update call status
                await database.ref(`calls/${currentCallId}/status`).set('accepted');

                // Listen for remote ICE candidates
                database.ref(`calls/${currentCallId}/candidates/${call.callerId}`).on('child_added', async (snapshot) => {
                    const candidate = snapshot.val().candidate;
                    if (peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                });

                // Listen for call end
                database.ref(`calls/${currentCallId}/status`).on('value', (snapshot) => {
                    const status = snapshot.val();
                    if (status === 'ended') {
                        endCall();
                    }
                });

                startCallTimer();
                document.getElementById('callStatus').textContent = 'Connected';
                document.getElementById('muteBtn').style.display = 'block';

            } catch (error) {
                console.error('Error accepting call:', error);
                alert('Error accepting call: ' + error.message);
                endCall();
            }
        }

        // Reject call
        async function rejectCall() {
            document.getElementById('incomingCallModal').style.display = 'none';
            if (currentCallId) {
                await database.ref(`calls/${currentCallId}/status`).set('rejected');
                currentCallId = null;
            }
        }

        // End call
        async function endCall() {
            // Stop call timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Clear remote stream
            if (remoteStream) {
                remoteStream = null;
            }

            // Update call status in Firebase
            if (currentCallId) {
                await database.ref(`calls/${currentCallId}/status`).set('ended');
                database.ref(`calls/${currentCallId}`).off();
                currentCallId = null;
            }

            // Hide modals
            document.getElementById('callModal').style.display = 'none';
            document.getElementById('incomingCallModal').style.display = 'none';

            // Reset UI
            document.getElementById('callTimer').style.display = 'none';
            document.getElementById('callTimer').textContent = '00:00';
            document.getElementById('muteBtn').style.display = 'none';
            document.getElementById('videoBtn').style.display = 'none';
            isMuted = false;
            isVideoOn = false;
        }

        // Toggle mute
        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    isMuted = !isMuted;
                    audioTrack.enabled = !isMuted;
                    document.getElementById('muteIcon').textContent = isMuted ? 'ğŸ”‡' : 'ğŸ¤';
                }
            }
        }

        // Toggle video (placeholder - can be extended)
        function toggleVideo() {
            alert('Video calling coming soon!');
        }

        // Start call timer
        function startCallTimer() {
            callStartTime = Date.now();
            document.getElementById('callTimer').style.display = 'block';

            callTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('callTimer').textContent =
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Image modal viewer
        let currentImageMessages = {};

        function openImageModal(messageId) {
            const msg = currentImageMessages[messageId];
            if (!msg || !msg.imageData) {
                console.error('Image not found');
                return;
            }

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="image-modal-content">
                    <span class="image-modal-close">&times;</span>
                    <img src="${msg.imageData}" alt="${escapeHtml(msg.imageName || 'image')}" class="image-modal-img">
                    <div class="image-modal-caption">${escapeHtml(msg.imageName || 'image.jpg')}</div>
                </div>
            `;

            document.body.appendChild(modal);

            // Close modal on click
            modal.addEventListener('click', function(e) {
                if (e.target === modal || e.target.className === 'image-modal-close') {
                    document.body.removeChild(modal);
                }
            });

            // Close on Escape key
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    if (document.body.contains(modal)) {
                        document.body.removeChild(modal);
                    }
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        async function updatePassword() {
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmNewPassword = document.getElementById('confirmNewPassword').value;

            if (!currentPassword || !newPassword || !confirmNewPassword) {
                showProfileMessage('Please fill in all password fields', 'warning');
                return;
            }

            if (newPassword.length < 6) {
                showProfileMessage('New password must be at least 6 characters', 'warning');
                return;
            }

            if (newPassword !== confirmNewPassword) {
                showProfileMessage('New passwords do not match!', 'error');
                return;
            }

            try {
                // Verify current password
                const currentHashedPassword = await hashPassword(currentPassword);
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                let userFound = false;
                for (let userId in users) {
                    if (userId === currentUser.id) {
                        if (users[userId].password !== currentHashedPassword) {
                            showProfileMessage('Current password is incorrect!', 'error');
                            return;
                        }
                        userFound = true;
                        break;
                    }
                }

                if (!userFound) {
                    showProfileMessage('User not found!', 'error');
                    return;
                }

                // Update password in Firebase
                const newHashedPassword = await hashPassword(newPassword);
                await database.ref('users/' + currentUser.id).update({
                    password: newHashedPassword
                });

                // Clear password fields
                document.getElementById('currentPassword').value = '';
                document.getElementById('newPassword').value = '';
                document.getElementById('confirmNewPassword').value = '';

                showProfileMessage('Password changed successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error changing password: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>

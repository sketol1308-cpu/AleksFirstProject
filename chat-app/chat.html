<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatApp - Messages</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <button class="back-btn" id="backBtn" onclick="backToPublicChat()" style="display: none;">‚Üê Back</button>
            <div class="user-info">
                <div class="user-avatar" id="currentUserAvatar">üòÄ</div>
                <div class="user-details">
                    <h2 id="currentUsername">User</h2>
                    <p id="chatMode">Public Chat</p>
                </div>
            </div>
            <div class="header-actions">
                <button class="notification-toggle-btn" id="notificationIcon" onclick="toggleNotifications()" title="Notifications ON">üîî</button>
                <button class="settings-btn" onclick="openProfileSettings()" title="Profile Settings">‚öôÔ∏è</button>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <div class="users-section">
            <div class="users-tabs">
                <button class="users-tab active" id="onlineTab" onclick="switchUsersTab('online')">
                    ONLINE (<span id="onlineCount">0</span>)
                </button>
                <button class="users-tab" id="allUsersTab" onclick="switchUsersTab('all')">
                    ALL USERS (<span id="allUsersCount">0</span>)
                </button>
            </div>
            <div class="users-list" id="usersList"></div>
        </div>

        <div class="messages-area" id="messagesArea">
            <div class="empty-state">
                <div class="empty-icon">üí¨</div>
                <p>Start chatting with others!</p>
            </div>
        </div>

        <div class="typing-indicator" id="typingIndicator" style="display: none;">
            <span id="typingText"></span>
            <span class="typing-dots">
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
            </span>
        </div>

        <!-- User Profile View Modal -->
        <div class="user-profile-modal" id="userProfileModal" style="display: none;">
            <div class="user-profile-content">
                <div class="user-profile-header">
                    <h2>User Profile</h2>
                    <button class="close-modal-btn" id="closeUserProfileBtn">‚úï</button>
                </div>

                <div class="user-profile-body">
                    <div class="profile-avatar-large" id="viewProfileAvatar">üòÄ</div>
                    <h3 id="viewProfileUsername">Username</h3>
                    <div class="profile-info">
                        <div class="profile-info-item">
                            <span class="profile-info-label">Member Since</span>
                            <span class="profile-info-value" id="viewProfileJoined">Just now</span>
                        </div>
                        <div class="profile-info-item">
                            <span class="profile-info-label">User ID</span>
                            <span class="profile-info-value" id="viewProfileId">-</span>
                        </div>
                    </div>
                    <button class="chat-with-user-btn" id="chatWithUserBtn">Send Message</button>
                </div>
            </div>
        </div>

        <!-- Profile Settings Modal -->
        <div class="profile-modal" id="profileModal" style="display: none;">
            <div class="profile-modal-content">
                <div class="profile-modal-header">
                    <h2>Profile Settings</h2>
                    <button class="close-modal-btn" onclick="closeProfileSettings()">‚úï</button>
                </div>

                <div class="profile-section">
                    <h3>Avatar</h3>
                    <div class="current-avatar-display">
                        <div class="big-avatar" id="currentAvatarDisplay">üòÄ</div>
                    </div>
                    <div class="avatar-selector" id="profileAvatarSelector">
                        <div class="avatar-option" data-avatar="üòÄ">üòÄ</div>
                        <div class="avatar-option" data-avatar="üòé">üòé</div>
                        <div class="avatar-option" data-avatar="ü§©">ü§©</div>
                        <div class="avatar-option" data-avatar="ü•≥">ü•≥</div>
                        <div class="avatar-option" data-avatar="üò∫">üò∫</div>
                        <div class="avatar-option" data-avatar="ü¶ä">ü¶ä</div>
                        <div class="avatar-option" data-avatar="üêº">üêº</div>
                        <div class="avatar-option" data-avatar="ü¶Ñ">ü¶Ñ</div>
                    </div>
                    <button class="save-profile-btn" onclick="updateAvatar()">Save Avatar</button>
                </div>

                <div class="profile-section">
                    <h3>Username</h3>
                    <div class="input-group">
                        <label for="newUsername">New Username</label>
                        <input type="text" id="newUsername" placeholder="Enter new username" minlength="3">
                    </div>
                    <button class="save-profile-btn" onclick="updateUsername()">Save Username</button>
                </div>

                <div class="profile-section">
                    <h3>Change Password</h3>
                    <div class="input-group">
                        <label for="currentPassword">Current Password</label>
                        <input type="password" id="currentPassword" placeholder="Enter current password" minlength="6">
                    </div>
                    <div class="input-group">
                        <label for="newPassword">New Password</label>
                        <input type="password" id="newPassword" placeholder="Enter new password" minlength="6">
                    </div>
                    <div class="input-group">
                        <label for="confirmNewPassword">Confirm New Password</label>
                        <input type="password" id="confirmNewPassword" placeholder="Confirm new password" minlength="6">
                    </div>
                    <button class="save-profile-btn" onclick="updatePassword()">Change Password</button>
                </div>

                <div id="profileMessage" style="display: none;"></div>
            </div>
        </div>

        <div class="input-area">
            <div class="emoji-picker" id="emojiPicker" style="display: none;">
                <div class="emoji-header">
                    <span class="emoji-category active" data-category="smileys">üòÄ</span>
                    <span class="emoji-category" data-category="gestures">üëã</span>
                    <span class="emoji-category" data-category="hearts">‚ù§Ô∏è</span>
                    <span class="emoji-category" data-category="animals">üê∂</span>
                    <span class="emoji-category" data-category="food">üçï</span>
                    <span class="emoji-category" data-category="activities">‚öΩ</span>
                    <span class="emoji-category" data-category="objects">üí°</span>
                </div>
                <div class="emoji-grid" id="emojiGrid"></div>
            </div>
            <div class="input-container">
                <button class="emoji-btn" id="emojiBtn" onclick="toggleEmojiPicker()">üòä</button>
                <button class="image-btn" id="imageBtn" onclick="document.getElementById('imageInput').click()" title="Send Image/GIF">üì∑</button>
                <button class="gif-btn" id="gifBtn" onclick="toggleGifPicker()" title="Search GIFs">GIF</button>
                <button class="gift-btn" id="giftBtn" onclick="toggleGiftPicker()" title="Send a Gift">üéÅ</button>
                <input type="file" id="imageInput" accept="image/*,image/gif" style="display: none;">
                <input
                    type="text"
                    class="message-input"
                    id="messageInput"
                    placeholder="Type a message..."
                    maxlength="500"
                    autocomplete="off"
                >
                <button class="send-btn" onclick="sendMessage()">Send</button>
            </div>

            <!-- GIF Picker -->
            <div class="gif-picker" id="gifPicker" style="display: none;">
                <div class="gif-picker-header">
                    <input type="text" id="gifSearchInput" placeholder="Search GIFs..." class="gif-search-input">
                    <button class="gif-close-btn" onclick="toggleGifPicker()">‚úï</button>
                </div>
                <div class="gif-grid" id="gifGrid">
                    <div class="gif-loading">Loading trending GIFs...</div>
                </div>
            </div>

            <!-- Gift Picker -->
            <div class="gift-picker" id="giftPicker" style="display: none;">
                <div class="gift-picker-header">
                    <span class="gift-picker-title">Send a Gift</span>
                    <button class="gift-close-btn" onclick="toggleGiftPicker()">‚úï</button>
                </div>
                <div class="gift-grid" id="giftGrid"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // YOUR REAL Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAM9AVeKv8po7D16h6XM422Eh0heq3hAW0",
            authDomain: "chat-app-with-claude.firebaseapp.com",
            databaseURL: "https://chat-app-with-claude-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "chat-app-with-claude",
            storageBucket: "chat-app-with-claude.firebasestorage.app",
            messagingSenderId: "163903134612",
            appId: "1:163903134612:web:8317fa2bc619563d0b8d81"
        };

        let database;

        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('‚úÖ Firebase Database connected!');
        } catch (error) {
            console.error('‚ùå Firebase error:', error);
            alert('Error connecting to Firebase: ' + error.message);
        }

        const currentUser = JSON.parse(localStorage.getItem('chatapp_user'));

        if (!currentUser) {
            window.location.href = 'index.html';
        }

        document.getElementById('currentUserAvatar').textContent = currentUser.avatar;
        document.getElementById('currentUsername').textContent = currentUser.username;

        // Chat mode: 'public' or 'private'
        let chatMode = 'public';
        let selectedUser = null;

        // Users display mode: 'online' or 'all'
        let usersDisplayMode = 'online';
        let allUsersData = {};
        let onlineUsersData = {};

        // Notification sounds
        let notificationEnabled = localStorage.getItem('chatapp_notifications') !== 'false';
        let browserNotificationsAllowed = localStorage.getItem('chatapp_notifications_allowed') === 'true';
        let previousMessageIds = new Set();

        // Audio context for notifications (initialized on first user interaction)
        let audioContext = null;
        let audioContextInitialized = false;

        // Initialize audio context (called on user interaction)
        function initAudioContext() {
            if (audioContextInitialized) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContextInitialized = true;
                console.log('Audio context initialized');

                // Resume context if suspended (Safari/iOS requirement)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.error('Error initializing audio context:', error);
            }
        }

        // Initialize audio on any user interaction
        const initAudioEvents = ['click', 'touchstart', 'keydown'];
        initAudioEvents.forEach(event => {
            document.addEventListener(event, initAudioContext, { once: true });
        });

        // Create notification sound using Web Audio API (mobile-friendly)
        function playNotificationSound() {
            if (!notificationEnabled) return;

            try {
                // Initialize audio context if not done yet
                if (!audioContextInitialized) {
                    initAudioContext();
                }

                if (!audioContext) {
                    console.warn('Audio context not available');
                    return;
                }

                // Resume context if suspended (important for mobile)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playSound();
                    }).catch(err => {
                        console.error('Failed to resume audio context:', err);
                    });
                } else {
                    playSound();
                }

                function playSound() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                }
            } catch (error) {
                console.error('Error playing notification sound:', error);
            }
        }

        // Show browser notification
        function showBrowserNotification(username, message, avatar) {
            if (!browserNotificationsAllowed) return;
            if (!("Notification" in window)) return;
            if (Notification.permission !== "granted") return;

            // Don't show notification if window is focused
            if (document.hasFocus()) return;

            try {
                const notification = new Notification(`${avatar} ${username}`, {
                    body: message,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">' + avatar + '</text></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">üí¨</text></svg>',
                    tag: 'chatapp-message',
                    requireInteraction: false,
                    silent: true // We already have sound notification
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };

                // Auto close after 5 seconds
                setTimeout(() => {
                    notification.close();
                }, 5000);
            } catch (error) {
                console.error('Error showing browser notification:', error);
            }
        }

        function toggleNotifications() {
            notificationEnabled = !notificationEnabled;
            localStorage.setItem('chatapp_notifications', notificationEnabled);
            updateNotificationIcon();
        }

        function updateNotificationIcon() {
            const icon = document.getElementById('notificationIcon');
            if (icon) {
                icon.textContent = notificationEnabled ? 'üîî' : 'üîï';
                icon.title = notificationEnabled ? 'Notifications ON' : 'Notifications OFF';
            }
        }

        // Visual notification flash (mobile-friendly fallback)
        function flashNotification() {
            if (!notificationEnabled) return;

            try {
                const header = document.querySelector('.chat-header');
                if (!header) return;

                // Add flash animation
                header.style.animation = 'none';
                setTimeout(() => {
                    header.style.animation = 'headerFlash 0.5s ease-out';
                }, 10);

                // Reset animation after completion
                setTimeout(() => {
                    header.style.animation = '';
                }, 600);
            } catch (error) {
                console.error('Error showing visual notification:', error);
            }
        }

        // Set initial notification icon state
        setTimeout(() => {
            updateNotificationIcon();
        }, 100);

        // Mark user as online
        const onlineUserRef = database.ref('online/' + currentUser.id);
        onlineUserRef.set({
            username: currentUser.username,
            avatar: currentUser.avatar,
            lastSeen: firebase.database.ServerValue.TIMESTAMP
        });

        // Remove user when they disconnect
        onlineUserRef.onDisconnect().remove();

        // Remove typing status when they disconnect
        database.ref('typing/public/' + currentUser.id).onDisconnect().remove();

        // Listen for online users
        database.ref('online').on('value', (snapshot) => {
            onlineUsersData = snapshot.val() || {};
            updateUsersDisplay();
        });

        // Listen for all users
        database.ref('users').on('value', (snapshot) => {
            allUsersData = snapshot.val() || {};
            updateUsersDisplay();
        });

        // Switch between online and all users tabs
        function switchUsersTab(mode) {
            usersDisplayMode = mode;

            const onlineTab = document.getElementById('onlineTab');
            const allUsersTab = document.getElementById('allUsersTab');

            if (mode === 'online') {
                onlineTab.classList.add('active');
                allUsersTab.classList.remove('active');
            } else {
                onlineTab.classList.remove('active');
                allUsersTab.classList.add('active');
            }

            updateUsersDisplay();
        }

        // Update users display based on current mode
        function updateUsersDisplay() {
            const usersList = document.getElementById('usersList');
            const onlineCount = document.getElementById('onlineCount');
            const allUsersCount = document.getElementById('allUsersCount');

            usersList.innerHTML = '';

            // Count online users (excluding current user)
            let onlineUserCount = 0;
            for (let userId in onlineUsersData) {
                if (userId !== currentUser.id) {
                    onlineUserCount++;
                }
            }

            // Count all users (excluding current user)
            let totalUserCount = 0;
            for (let userId in allUsersData) {
                if (userId !== currentUser.id) {
                    totalUserCount++;
                }
            }

            onlineCount.textContent = onlineUserCount;
            allUsersCount.textContent = totalUserCount;

            if (usersDisplayMode === 'online') {
                // Display only online users
                for (let userId in onlineUsersData) {
                    if (userId !== currentUser.id) {
                        const user = onlineUsersData[userId];
                        displayUser(userId, user, true);
                    }
                }
            } else {
                // Display all users
                for (let userId in allUsersData) {
                    if (userId !== currentUser.id) {
                        const user = allUsersData[userId];
                        const isOnline = onlineUsersData.hasOwnProperty(userId);
                        displayUser(userId, user, isOnline);
                    }
                }
            }
        }

        // Display a single user in the list
        function displayUser(userId, user, isOnline) {
            const usersList = document.getElementById('usersList');
            const userElement = document.createElement('div');
            userElement.className = isOnline ? 'user-item online' : 'user-item offline';
            userElement.style.cursor = 'pointer';
            userElement.setAttribute('data-user-id', userId);

            const statusClass = isOnline ? 'online' : 'offline';
            userElement.innerHTML = `
                <div class="user-avatar">${user.avatar || 'üòÄ'}</div>
                <div class="user-name">${user.username || 'Unknown'}</div>
                <div class="user-status-indicator ${statusClass}"></div>
            `;

            // Add click event to view profile
            userElement.addEventListener('click', (e) => {
                e.preventDefault();
                viewUserProfile(userId, user);
            });

            // Add touch event for mobile
            userElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                viewUserProfile(userId, user);
            });

            usersList.appendChild(userElement);
        }

        // Listen for messages
        let messagesListener = null;

        function updateMessagesListener() {
            // Remove old listener
            if (messagesListener) {
                database.ref('messages').off('value', messagesListener);
                database.ref('privateMessages').off('value', messagesListener);
            }

            const messagesArea = document.getElementById('messagesArea');

            if (chatMode === 'public') {
                messagesListener = database.ref('messages').on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    const messagesWithIds = Object.keys(messages).map(id => ({
                        ...messages[id],
                        messageId: id
                    }));
                    displayMessages(messagesWithIds, messagesArea);
                });
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagesListener = database.ref('privateMessages/' + chatId).on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    const messagesWithIds = Object.keys(messages).map(id => ({
                        ...messages[id],
                        messageId: id
                    }));
                    displayMessages(messagesWithIds, messagesArea);
                });
            }
        }

        function displayMessages(messagesList, messagesArea) {
            console.log('displayMessages called with', messagesList.length, 'messages');
            messagesList = messagesList.sort((a, b) => {
                const aTime = a.timestamp || 0;
                const bTime = b.timestamp || 0;
                return aTime - bTime;
            });

            if (messagesList.length === 0) {
                const emptyText = chatMode === 'private'
                    ? `Start chatting with ${selectedUser.username}!`
                    : 'Start chatting with others!';
                messagesArea.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üí¨</div>
                        <p>${emptyText}</p>
                    </div>
                `;
                return;
            }

            // Check for new messages and play notification sound + show browser notification
            try {
                const currentMessageIds = new Set(messagesList.map(msg => msg.messageId).filter(id => id));
                let newMessagesFromOthers = [];

                for (const msg of messagesList) {
                    if (msg && msg.messageId && !previousMessageIds.has(msg.messageId)) {
                        const msgUserId = msg.userId || 'unknown';
                        if (msgUserId !== currentUser.id) {
                            newMessagesFromOthers.push(msg);
                        }
                    }
                }

                if (newMessagesFromOthers.length > 0 && previousMessageIds.size > 0) {
                    playNotificationSound();

                    // Visual notification flash (fallback for mobile)
                    flashNotification();

                    // Show browser notification for the latest new message
                    const latestMsg = newMessagesFromOthers[newMessagesFromOthers.length - 1];
                    const username = latestMsg.username || 'Unknown User';
                    const avatar = latestMsg.avatar || 'üòÄ';
                    let text = latestMsg.text || '';
                    if (latestMsg.type === 'image') {
                        text = 'üì∑ Image';
                    } else if (latestMsg.type === 'gift' && latestMsg.gift) {
                        text = `${latestMsg.gift.emoji} Sent a ${latestMsg.gift.name}`;
                    }
                    showBrowserNotification(username, text, avatar);
                }

                previousMessageIds = currentMessageIds;
            } catch (error) {
                console.error('Error in notification detection:', error);
            }

            try {
                console.log('Rendering', messagesList.length, 'messages...');

                // Store image messages for modal viewing
                currentImageMessages = {};
                messagesList.forEach(msg => {
                    if (msg && msg.messageId && msg.type === 'image' && msg.imageData) {
                        currentImageMessages[msg.messageId] = msg;
                    }
                });

                messagesArea.innerHTML = messagesList.map(msg => {
                // Skip messages with missing critical data (text, image, or gift)
                if (!msg || !msg.messageId || (!msg.text && !msg.imageData && !msg.gift)) {
                    console.warn('Skipping invalid message:', msg);
                    return '';
                }

                // Provide defaults for missing properties
                const userId = msg.userId || 'unknown';
                const username = msg.username || 'Unknown User';
                const avatar = msg.avatar || 'üòÄ';
                const timestamp = msg.timestamp || Date.now();

                const isOwn = userId === currentUser.id;
                const messageClass = isOwn ? 'message own' : 'message';
                const editButton = isOwn && msg.type !== 'image' ? `<button class="edit-msg-btn" onclick="startEditMessage('${msg.messageId}')" title="Edit message">‚úèÔ∏è</button>` : '';
                const deleteButton = isOwn ? `<button class="delete-msg-btn" onclick="deleteMessage('${msg.messageId}')" title="Delete message">üóëÔ∏è</button>` : '';
                const editedLabel = msg.edited ? '<span class="edited-label">(edited)</span>' : '';

                // Build reactions display
                let reactionsHtml = '';
                if (msg.reactions) {
                    const reactionCounts = {};
                    for (let userId in msg.reactions) {
                        const emoji = msg.reactions[userId];
                        reactionCounts[emoji] = (reactionCounts[emoji] || 0) + 1;
                    }

                    reactionsHtml = '<div class="message-reactions">';
                    for (let emoji in reactionCounts) {
                        const count = reactionCounts[emoji];
                        const hasReacted = msg.reactions[currentUser.id] === emoji;
                        const reactionClass = hasReacted ? 'reaction-badge active' : 'reaction-badge';
                        reactionsHtml += `<span class="${reactionClass}" onclick="toggleReaction('${msg.messageId}', '${emoji}')">${emoji} ${count}</span>`;
                    }
                    reactionsHtml += '</div>';
                }

                // Build read receipt display
                let readReceiptHtml = '';
                if (isOwn && msg.readBy) {
                    const readByCount = Object.keys(msg.readBy).filter(id => id !== currentUser.id).length;
                    if (chatMode === 'private' && selectedUser) {
                        // Private chat: show checkmark if other person read it
                        const isReadByOther = msg.readBy[selectedUser.id];
                        if (isReadByOther) {
                            readReceiptHtml = '<span class="read-receipt read" title="Read">‚úì‚úì</span>';
                        } else {
                            readReceiptHtml = '<span class="read-receipt delivered" title="Delivered">‚úì</span>';
                        }
                    } else if (chatMode === 'public') {
                        // Public chat: show count if read by others
                        if (readByCount > 0) {
                            readReceiptHtml = `<span class="read-receipt read" title="Read by ${readByCount} ${readByCount === 1 ? 'person' : 'people'}">‚úì‚úì</span>`;
                        } else {
                            readReceiptHtml = '<span class="read-receipt delivered" title="Delivered">‚úì</span>';
                        }
                    }
                }

                // Build message content (text, image, or gift)
                let messageContent = '';
                if (msg.type === 'gift' && msg.gift) {
                    messageContent = `
                        <div class="gift-message">
                            <div class="gift-box">
                                <div class="gift-emoji-large">${msg.gift.emoji}</div>
                                <div class="gift-label">${msg.gift.name}</div>
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'image' && msg.imageData) {
                    messageContent = `
                        <div class="image-message">
                            <img src="${msg.imageData}" alt="${escapeHtml(msg.imageName || 'image')}" class="message-image" onclick="openImageModal('${msg.messageId}')">
                            <div class="image-name">${escapeHtml(msg.imageName || 'image.jpg')}</div>
                        </div>
                    `;
                } else {
                    messageContent = `<span class="message-text" data-original-text="${escapeHtml(msg.text)}">${escapeHtml(msg.text)} ${editedLabel}</span>`;
                }

                return `
                    <div class="${messageClass}" data-message-id="${msg.messageId}">
                        <div class="message-avatar">${avatar}</div>
                        <div class="message-content">
                            <div class="message-header">${username}</div>
                            <div class="message-bubble">
                                ${messageContent}
                                <div class="message-actions" style="display: none;">
                                    <button class="react-msg-btn" onclick="showReactionPicker('${msg.messageId}')" title="Add reaction">üòä</button>
                                    ${editButton}
                                    ${deleteButton}
                                </div>
                            </div>
                            ${reactionsHtml}
                            <div class="message-time">${formatTime(timestamp)} ${readReceiptHtml}</div>
                        </div>
                    </div>
                `;
                }).filter(html => html !== '').join('');

                console.log('Messages rendered successfully');

                // Add context menu (right-click) listeners
                document.querySelectorAll('.message').forEach(messageEl => {
                messageEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();

                    // Hide all other action buttons first
                    document.querySelectorAll('.message-actions').forEach(actions => {
                        actions.style.display = 'none';
                    });

                    // Show actions for this message
                    const actions = messageEl.querySelector('.message-actions');
                    if (actions) {
                        actions.style.display = 'flex';
                    }
                });

                // For mobile: long press to show actions
                let pressTimer;
                messageEl.addEventListener('touchstart', (e) => {
                    pressTimer = setTimeout(() => {
                        // Hide all other action buttons first
                        document.querySelectorAll('.message-actions').forEach(actions => {
                            actions.style.display = 'none';
                        });

                        // Show actions for this message
                        const actions = messageEl.querySelector('.message-actions');
                        if (actions) {
                            actions.style.display = 'flex';
                        }
                    }, 500);
                });

                messageEl.addEventListener('touchend', () => {
                    clearTimeout(pressTimer);
                });

                messageEl.addEventListener('touchmove', () => {
                    clearTimeout(pressTimer);
                });
            });

                messagesArea.scrollTop = messagesArea.scrollHeight;

                // Setup Intersection Observer for read receipts
                setupReadReceiptObserver();
            } catch (error) {
                console.error('Error in message display:', error);
                console.error('Error details:', error.message, error.stack);
                messagesArea.innerHTML = '<div class="empty-state"><div class="empty-icon">‚ö†Ô∏è</div><p>Error loading messages. Check console for details.</p></div>';
            }
        }

        // Read Receipt Observer
        let readReceiptObserver = null;
        let markedAsReadMessages = new Set(); // Track messages already marked as read

        function setupReadReceiptObserver() {
            // Disconnect previous observer
            if (readReceiptObserver) {
                readReceiptObserver.disconnect();
            }

            // Create new observer
            readReceiptObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const messageId = entry.target.getAttribute('data-message-id');
                        const messageElement = entry.target;

                        // Check if this is someone else's message
                        const isOwnMessage = messageElement.classList.contains('own');
                        if (!isOwnMessage && messageId) {
                            markMessageAsRead(messageId);
                        }
                    }
                });
            }, {
                root: document.getElementById('messagesArea'),
                threshold: 0.5 // Message must be 50% visible
            });

            // Observe all message elements
            document.querySelectorAll('.message').forEach(messageEl => {
                readReceiptObserver.observe(messageEl);
            });
        }

        function markMessageAsRead(messageId) {
            // Don't mark the same message twice
            if (markedAsReadMessages.has(messageId)) {
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/readBy/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/readBy/' + currentUser.id;
            } else {
                return;
            }

            // Check if already marked as read in Firebase before updating
            database.ref(messagePath).once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        // Only mark if not already marked
                        markedAsReadMessages.add(messageId);
                        return database.ref(messagePath).set(Date.now());
                    }
                })
                .catch(error => {
                    console.error('Error marking message as read:', error);
                });
        }

        function getChatId(userId1, userId2) {
            return [userId1, userId2].sort().join('_');
        }

        updateMessagesListener();

        // Hide message actions when clicking outside (add once globally)
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.message') && !e.target.closest('.message-actions')) {
                document.querySelectorAll('.message-actions').forEach(actions => {
                    actions.style.display = 'none';
                });
            }
        });

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const text = messageInput.value.trim();

            if (!text) return;

            const message = {
                userId: currentUser.id,
                username: currentUser.username,
                avatar: currentUser.avatar,
                text: text,
                timestamp: Date.now()
            };

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages';
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId;
            } else {
                return;
            }

            database.ref(messagePath).push(message)
                .then(() => {
                    messageInput.value = '';
                    messageInput.focus();
                })
                .catch(error => {
                    alert('Error sending message: ' + error.message);
                });
        }

        // Image upload functionality
        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            imageInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                console.log('Image file selected:', file.name, 'Size:', file.size, 'Type:', file.type);

                // Check file size (max 10MB for images/GIFs)
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxSize) {
                    alert('Image/GIF file is too large! Maximum size is 10MB.');
                    imageInput.value = '';
                    return;
                }

                // Check if it's an image
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    imageInput.value = '';
                    return;
                }

                const messageInput = document.getElementById('messageInput');
                const originalPlaceholder = messageInput.placeholder;

                try {
                    console.log('Processing image...');

                    // Show processing indicator
                    messageInput.placeholder = 'Processing image...';
                    messageInput.disabled = true;

                    // Convert image to base64
                    const reader = new FileReader();

                    reader.onload = async function(event) {
                        try {
                            const base64Image = event.target.result;
                            console.log('Image converted to base64');

                            // Send image message
                            const message = {
                                userId: currentUser.id,
                                username: currentUser.username,
                                avatar: currentUser.avatar,
                                imageData: base64Image,
                                imageName: file.name,
                                timestamp: Date.now(),
                                type: 'image'
                            };

                            let messagePath;
                            if (chatMode === 'public') {
                                messagePath = 'messages';
                            } else if (chatMode === 'private' && selectedUser) {
                                const chatId = getChatId(currentUser.id, selectedUser.id);
                                messagePath = 'privateMessages/' + chatId;
                            } else {
                                messageInput.placeholder = originalPlaceholder;
                                messageInput.disabled = false;
                                imageInput.value = '';
                                return;
                            }

                            console.log('Sending image message to:', messagePath);
                            await database.ref(messagePath).push(message);
                            console.log('Image message sent successfully!');

                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            imageInput.value = '';
                        } catch (error) {
                            console.error('Error sending image message:', error);
                            alert('Error sending image: ' + error.message);
                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            imageInput.value = '';
                        }
                    };

                    reader.onerror = function(error) {
                        console.error('Error reading file:', error);
                        alert('Error reading image file');
                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                        imageInput.value = '';
                    };

                    reader.readAsDataURL(file);

                } catch (error) {
                    console.error('Error processing image:', error);
                    alert('Error processing image: ' + error.message);
                    messageInput.placeholder = originalPlaceholder;
                    messageInput.disabled = false;
                    imageInput.value = '';
                }
            });
        }

        function deleteMessage(messageId) {
            if (!confirm('Are you sure you want to delete this message?')) {
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId;
            } else {
                return;
            }

            database.ref(messagePath).remove()
                .then(() => {
                    console.log('Message deleted successfully');
                })
                .catch(error => {
                    alert('Error deleting message: ' + error.message);
                });
        }

        function startEditMessage(messageId) {
            // Find the message element
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const messageBubble = messageElement.querySelector('.message-bubble');
            const messageTextSpan = messageElement.querySelector('.message-text');
            const originalText = messageTextSpan.getAttribute('data-original-text');

            // Replace message content with edit input
            messageBubble.innerHTML = `
                <input type="text" class="edit-message-input" value="${originalText}" maxlength="500" />
                <div class="edit-message-actions">
                    <button class="save-edit-btn" onclick="saveEditMessage('${messageId}')" title="Save">‚úì</button>
                    <button class="cancel-edit-btn" onclick="cancelEditMessage('${messageId}')" title="Cancel">‚úï</button>
                </div>
            `;

            // Focus the input
            const input = messageBubble.querySelector('.edit-message-input');
            input.focus();
            input.select();

            // Allow saving with Enter key
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEditMessage(messageId);
                } else if (e.key === 'Escape') {
                    cancelEditMessage(messageId);
                }
            });
        }

        function saveEditMessage(messageId) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const input = messageElement.querySelector('.edit-message-input');
            const newText = input.value.trim();

            if (!newText) {
                alert('Message cannot be empty!');
                return;
            }

            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId;
            } else {
                return;
            }

            database.ref(messagePath).update({
                text: newText,
                edited: true,
                editedAt: Date.now()
            })
            .then(() => {
                console.log('Message edited successfully');
            })
            .catch(error => {
                alert('Error editing message: ' + error.message);
            });
        }

        function cancelEditMessage(messageId) {
            // Just trigger a re-render by doing nothing - Firebase listener will restore original
            console.log('Edit cancelled');
        }

        // Reaction functions
        const quickReactions = ['‚ù§Ô∏è', 'üëç', 'üòÇ', 'üòÆ', 'üò¢', 'üôè', 'üéâ', 'üî•'];

        function showReactionPicker(messageId) {
            // Hide all reaction pickers first
            document.querySelectorAll('.reaction-picker').forEach(picker => picker.remove());

            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;

            const messageBubble = messageEl.querySelector('.message-bubble');

            // Create reaction picker
            const picker = document.createElement('div');
            picker.className = 'reaction-picker';
            picker.innerHTML = quickReactions.map(emoji =>
                `<button class="reaction-option" onclick="addReaction('${messageId}', '${emoji}')">${emoji}</button>`
            ).join('');

            messageBubble.appendChild(picker);

            // Close picker when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePickerHandler(e) {
                    if (!picker.contains(e.target)) {
                        picker.remove();
                        document.removeEventListener('click', closePickerHandler);
                    }
                }, { once: false });
            }, 100);
        }

        function addReaction(messageId, emoji) {
            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/reactions/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/reactions/' + currentUser.id;
            } else {
                return;
            }

            database.ref(messagePath).set(emoji)
                .then(() => {
                    // Remove picker
                    document.querySelectorAll('.reaction-picker').forEach(picker => picker.remove());
                })
                .catch(error => {
                    alert('Error adding reaction: ' + error.message);
                });
        }

        function toggleReaction(messageId, emoji) {
            let messagePath;
            if (chatMode === 'public') {
                messagePath = 'messages/' + messageId + '/reactions/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                messagePath = 'privateMessages/' + chatId + '/' + messageId + '/reactions/' + currentUser.id;
            } else {
                return;
            }

            // Check if user already reacted with this emoji
            database.ref(messagePath).once('value')
                .then(snapshot => {
                    if (snapshot.val() === emoji) {
                        // Remove reaction
                        return database.ref(messagePath).remove();
                    } else {
                        // Change to this reaction
                        return database.ref(messagePath).set(emoji);
                    }
                })
                .catch(error => {
                    alert('Error toggling reaction: ' + error.message);
                });
        }

        function startPrivateChat(userId, user) {
            console.log('startPrivateChat called with:', userId, user);
            chatMode = 'private';
            selectedUser = { id: userId, ...user };

            console.log('Chat mode set to:', chatMode, 'Selected user:', selectedUser);

            document.getElementById('chatMode').textContent = `Chatting with ${user.username}`;
            document.getElementById('backBtn').style.display = 'block';

            updateMessagesListener();
            updateTypingListener();

            console.log('Private chat started successfully');
        }

        function backToPublicChat() {
            chatMode = 'public';
            selectedUser = null;

            document.getElementById('chatMode').textContent = 'Public Chat';
            document.getElementById('backBtn').style.display = 'none';

            updateMessagesListener();
            updateTypingListener();
        }

        // Typing Indicator Logic
        let typingTimeout;
        let isTyping = false;

        function setTypingStatus(typing) {
            let typingPath;
            if (chatMode === 'public') {
                typingPath = 'typing/public/' + currentUser.id;
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                typingPath = 'typing/private/' + chatId + '/' + currentUser.id;
            } else {
                return;
            }

            if (typing) {
                database.ref(typingPath).set({
                    username: currentUser.username,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            } else {
                database.ref(typingPath).remove();
            }
        }

        // Listen for typing status
        function updateTypingListener() {
            // Remove old listeners
            database.ref('typing/public').off();
            database.ref('typing/private').off();

            if (chatMode === 'public') {
                database.ref('typing/public').on('value', (snapshot) => {
                    displayTypingIndicator(snapshot.val());
                });
            } else if (chatMode === 'private' && selectedUser) {
                const chatId = getChatId(currentUser.id, selectedUser.id);
                database.ref('typing/private/' + chatId).on('value', (snapshot) => {
                    displayTypingIndicator(snapshot.val());
                });
            }
        }

        function displayTypingIndicator(typingUsers) {
            const typingIndicator = document.getElementById('typingIndicator');
            const typingText = document.getElementById('typingText');

            if (!typingUsers) {
                typingIndicator.style.display = 'none';
                return;
            }

            const usersTyping = [];
            for (let userId in typingUsers) {
                if (userId !== currentUser.id) {
                    usersTyping.push(typingUsers[userId].username);
                }
            }

            if (usersTyping.length === 0) {
                typingIndicator.style.display = 'none';
            } else if (usersTyping.length === 1) {
                typingText.textContent = usersTyping[0] + ' is typing';
                typingIndicator.style.display = 'flex';
            } else if (usersTyping.length === 2) {
                typingText.textContent = usersTyping[0] + ' and ' + usersTyping[1] + ' are typing';
                typingIndicator.style.display = 'flex';
            } else {
                typingText.textContent = usersTyping.length + ' people are typing';
                typingIndicator.style.display = 'flex';
            }
        }

        updateTypingListener();

        const messageInput = document.getElementById('messageInput');

        messageInput.addEventListener('input', () => {
            // Initialize audio context on first input (mobile-friendly)
            initAudioContext();

            if (!isTyping) {
                isTyping = true;
                setTypingStatus(true);
            }

            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                isTyping = false;
                setTypingStatus(false);
            }, 2000);
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
                clearTimeout(typingTimeout);
                isTyping = false;
                setTypingStatus(false);
            }
        });

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                onlineUserRef.remove();
                localStorage.removeItem('chatapp_user');
                window.location.href = 'index.html';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;

            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }

        // Emoji Picker Functionality
        const emojiCategories = {
            smileys: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'ü•≤', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'üò∂‚Äçüå´Ô∏è', 'ü•¥', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'ü•∏', 'üòé', 'ü§ì', 'üßê'],
            gestures: ['üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', 'üí™', 'ü¶æ', 'ü¶ø', 'ü¶µ', 'ü¶∂', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üíã'],
            hearts: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù§Ô∏è‚Äçüî•', '‚ù§Ô∏è‚Äçü©π', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ', '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì'],
            animals: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ', 'üôà', 'üôâ', 'üôä', 'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò', 'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêè', 'üêë', 'ü¶ô', 'üêê', 'ü¶å', 'üêï', 'üê©', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üêà', 'üêà‚Äç‚¨õ', 'üêì', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶©', 'üïäÔ∏è', 'üêá', 'ü¶ù', 'ü¶®', 'ü¶°', 'ü¶¶', 'ü¶•', 'üêÅ', 'üêÄ', 'üêøÔ∏è', 'ü¶î'],
            food: ['üçï', 'üçî', 'üçü', 'üå≠', 'üçø', 'üßà', 'ü•ì', 'ü•ö', 'üç≥', 'üßá', 'ü•û', 'üßà', 'üçû', 'ü•ê', 'ü•®', 'ü•Ø', 'ü•ñ', 'üßÄ', 'ü•ó', 'ü•ô', 'ü•™', 'üåÆ', 'üåØ', 'ü´î', 'ü•´', 'üçñ', 'üçó', 'ü•©', 'üç†', 'ü•ü', 'ü•†', 'ü•°', 'üç±', 'üçò', 'üçô', 'üçö', 'üçõ', 'üçú', 'ü¶™', 'üç£', 'üç§', 'üç•', 'ü•Æ', 'üç¢', 'üßÜ', 'ü•ò', 'üç≤', 'ü´ï', 'üçù', 'ü•ß', 'üç∞', 'üéÇ', 'üßÅ', 'üçÆ', 'üç≠', 'üç¨', 'üç´', 'üçø', 'üç©', 'üç™', 'üå∞', 'ü•ú', 'üçØ', 'ü•õ', 'üçº', '‚òï', 'üçµ', 'üßÉ', 'ü•§', 'üç∂', 'üç∫', 'üçª', 'ü•Ç', 'üç∑', 'ü•É', 'üç∏', 'üçπ', 'üßâ', 'üçæ', 'üßä', 'ü•Ñ', 'üç¥', 'üçΩÔ∏è', 'ü•£', 'ü•°', 'ü•¢', 'üßÇ'],
            activities: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõº', 'üõ∑', '‚õ∏Ô∏è', 'ü•å', 'üéø', '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è', 'ü§º', 'ü§∏', 'ü§æ', 'üèåÔ∏è', 'üèá', 'üßò', 'üèä', 'ü§Ω', 'üö£', 'üßó', 'üöµ', 'üö¥', 'üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üéóÔ∏è', 'üé´', 'üéüÔ∏è', 'üé™', 'üé≠', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'üé∑', 'üé∫', 'üé∏', 'ü™ï', 'üéª', 'üé≤', '‚ôüÔ∏è', 'üéØ', 'üé≥', 'üéÆ', 'üé∞', 'üß©'],
            objects: ['üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'ü™ô', 'üí∞', 'üí≥', 'üíé', '‚öñÔ∏è', 'ü™ú', 'üß∞', 'ü™õ', 'üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚õèÔ∏è', 'ü™ö', 'üî©', '‚öôÔ∏è', 'ü™§', 'üß±', '‚õìÔ∏è', 'üß≤', 'üî´', 'üí£', 'üß®', 'ü™ì', 'üî™', 'üó°Ô∏è', '‚öîÔ∏è', 'üõ°Ô∏è', 'üö¨', '‚ö∞Ô∏è', 'ü™¶', '‚ö±Ô∏è', 'üè∫', 'üîÆ', 'üìø', 'üßø', 'üíà', '‚öóÔ∏è', 'üî≠', 'üî¨', 'üï≥Ô∏è', 'ü©π', 'ü©∫', 'üíä', 'üíâ', 'ü©∏', 'üß¨', 'ü¶†', 'üß´', 'üß™', 'üå°Ô∏è', 'üßπ', 'ü™†', 'üß∫', 'üßª', 'üöΩ', 'üö∞', 'üöø', 'üõÅ', 'üõÄ', 'üßº', 'ü™í', 'üßΩ', 'ü™£', 'üß¥', 'üß∑', 'üßπ', 'üß∫', 'üßª', 'ü™£']
        };

        let currentCategory = 'smileys';

        function loadEmojis(category) {
            const emojiGrid = document.getElementById('emojiGrid');
            emojiGrid.innerHTML = '';
            const emojis = emojiCategories[category] || emojiCategories.smileys;

            emojis.forEach(emoji => {
                const emojiElement = document.createElement('span');
                emojiElement.className = 'emoji-item';
                emojiElement.textContent = emoji;
                emojiElement.addEventListener('click', () => insertEmoji(emoji));
                emojiElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    insertEmoji(emoji);
                });
                emojiGrid.appendChild(emojiElement);
            });
        }

        function toggleEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            if (picker.style.display === 'none') {
                picker.style.display = 'block';
                loadEmojis(currentCategory);
            } else {
                picker.style.display = 'none';
            }
        }

        function insertEmoji(emoji) {
            const input = document.getElementById('messageInput');
            const cursorPos = input.selectionStart;
            const textBefore = input.value.substring(0, cursorPos);
            const textAfter = input.value.substring(cursorPos);
            input.value = textBefore + emoji + textAfter;
            input.focus();
            input.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
        }

        // Emoji category switching
        document.addEventListener('DOMContentLoaded', function() {
            const categoryButtons = document.querySelectorAll('.emoji-category');
            categoryButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    categoryButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentCategory = this.getAttribute('data-category');
                    loadEmojis(currentCategory);
                });
            });

            // Close emoji picker when clicking outside
            document.addEventListener('click', function(e) {
                const picker = document.getElementById('emojiPicker');
                const emojiBtn = document.getElementById('emojiBtn');
                if (picker.style.display === 'block' && !picker.contains(e.target) && e.target !== emojiBtn) {
                    picker.style.display = 'none';
                }
            });
        });

        // Profile Settings Functions
        let selectedProfileAvatar = currentUser.avatar;

        function openProfileSettings() {
            const modal = document.getElementById('profileModal');
            const currentAvatarDisplay = document.getElementById('currentAvatarDisplay');
            const newUsernameInput = document.getElementById('newUsername');

            // Set current values
            currentAvatarDisplay.textContent = currentUser.avatar;
            selectedProfileAvatar = currentUser.avatar;
            newUsernameInput.value = currentUser.username;

            // Highlight current avatar
            const avatarOptions = document.querySelectorAll('#profileAvatarSelector .avatar-option');
            avatarOptions.forEach(option => {
                const emoji = option.getAttribute('data-avatar');
                if (emoji === currentUser.avatar) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });

            // Setup avatar selection
            avatarOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const emoji = this.getAttribute('data-avatar');
                    selectedProfileAvatar = emoji;
                    currentAvatarDisplay.textContent = emoji;

                    avatarOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            modal.style.display = 'flex';
        }

        function closeProfileSettings() {
            const modal = document.getElementById('profileModal');
            const profileMessage = document.getElementById('profileMessage');

            modal.style.display = 'none';
            profileMessage.style.display = 'none';

            // Clear password fields
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmNewPassword').value = '';
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('profileModal');
            if (e.target === modal) {
                closeProfileSettings();
            }
        });

        function showProfileMessage(message, type) {
            const profileMessage = document.getElementById('profileMessage');
            profileMessage.textContent = message;
            profileMessage.className = type;
            profileMessage.style.display = 'block';

            setTimeout(() => {
                profileMessage.style.display = 'none';
            }, 3000);
        }

        async function updateAvatar() {
            if (selectedProfileAvatar === currentUser.avatar) {
                showProfileMessage('No changes made to avatar', 'warning');
                return;
            }

            try {
                // Update in Firebase
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                for (let userId in users) {
                    if (userId === currentUser.id) {
                        await database.ref('users/' + userId).update({
                            avatar: selectedProfileAvatar
                        });
                        break;
                    }
                }

                // Update online status
                await onlineUserRef.update({
                    avatar: selectedProfileAvatar
                });

                // Update local storage and current user
                currentUser.avatar = selectedProfileAvatar;
                localStorage.setItem('chatapp_user', JSON.stringify(currentUser));

                // Update UI
                document.getElementById('currentUserAvatar').textContent = selectedProfileAvatar;

                showProfileMessage('Avatar updated successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error updating avatar: ' + error.message, 'error');
            }
        }

        async function updateUsername() {
            const newUsername = document.getElementById('newUsername').value.trim();

            if (!newUsername || newUsername.length < 3) {
                showProfileMessage('Username must be at least 3 characters', 'warning');
                return;
            }

            if (newUsername === currentUser.username) {
                showProfileMessage('No changes made to username', 'warning');
                return;
            }

            try {
                // Check if username is taken
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                for (let userId in users) {
                    if (userId !== currentUser.id && users[userId].username.toLowerCase() === newUsername.toLowerCase()) {
                        showProfileMessage('Username already taken!', 'error');
                        return;
                    }
                }

                // Update in Firebase
                for (let userId in users) {
                    if (userId === currentUser.id) {
                        await database.ref('users/' + userId).update({
                            username: newUsername
                        });
                        break;
                    }
                }

                // Update online status
                await onlineUserRef.update({
                    username: newUsername
                });

                // Update local storage and current user
                currentUser.username = newUsername;
                localStorage.setItem('chatapp_user', JSON.stringify(currentUser));

                // Update UI
                document.getElementById('currentUsername').textContent = newUsername;

                showProfileMessage('Username updated successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error updating username: ' + error.message, 'error');
            }
        }

        // User Profile View Functions
        let viewedUserData = null;
        let profileButtonsInitialized = false;

        // Initialize profile modal buttons once
        function initializeProfileButtons() {
            if (profileButtonsInitialized) return;

            const closeBtn = document.getElementById('closeUserProfileBtn');
            const chatBtn = document.getElementById('chatWithUserBtn');

            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    console.log('Close button clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    closeUserProfile();
                });
            }

            if (chatBtn) {
                chatBtn.addEventListener('click', function(e) {
                    console.log('=== Send Message button ACTUALLY clicked! ===');
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('viewedUserData:', viewedUserData);
                    chatWithViewedUser();
                });
            }

            profileButtonsInitialized = true;
            console.log('Profile buttons initialized');
        }

        async function viewUserProfile(userId, user) {
            console.log('viewUserProfile called with:', userId, user);
            viewedUserData = { id: userId, ...user };

            // Initialize buttons if not done yet
            initializeProfileButtons();

            const modal = document.getElementById('userProfileModal');
            const avatar = document.getElementById('viewProfileAvatar');
            const username = document.getElementById('viewProfileUsername');
            const joined = document.getElementById('viewProfileJoined');
            const userIdDisplay = document.getElementById('viewProfileId');

            avatar.textContent = user.avatar || 'üòÄ';
            username.textContent = user.username || 'Unknown User';
            userIdDisplay.textContent = userId.substring(0, 8) + '...';

            // Fetch user data from Firebase to get joinedAt
            try {
                const snapshot = await database.ref('users/' + userId).once('value');
                const userData = snapshot.val();

                if (userData && userData.joinedAt) {
                    const joinDate = new Date(userData.joinedAt);
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    joined.textContent = joinDate.toLocaleDateString('en-US', options);
                } else {
                    joined.textContent = 'Recently';
                }
            } catch (error) {
                console.error('Error fetching user data:', error);
                joined.textContent = 'Recently';
            }

            modal.style.display = 'flex';
        }

        function closeUserProfile() {
            const modal = document.getElementById('userProfileModal');
            modal.style.display = 'none';
            viewedUserData = null;
        }

        function chatWithViewedUser() {
            console.log('=== chatWithViewedUser called ===');
            console.log('viewedUserData:', viewedUserData);

            if (!viewedUserData) {
                console.error('ERROR: No viewedUserData available!');
                alert('Error: User data not available. Please try again.');
                return;
            }

            console.log('viewedUserData.id:', viewedUserData.id);
            console.log('viewedUserData.username:', viewedUserData.username);
            console.log('viewedUserData.avatar:', viewedUserData.avatar);

            // Save user data BEFORE closing modal (which sets viewedUserData to null)
            const userId = viewedUserData.id;
            const userForChat = {
                username: viewedUserData.username,
                avatar: viewedUserData.avatar
            };

            console.log('userForChat object:', userForChat);
            console.log('Closing profile modal...');
            closeUserProfile();

            console.log('Calling startPrivateChat with userId:', userId, 'and user:', userForChat);
            startPrivateChat(userId, userForChat);
            console.log('=== chatWithViewedUser finished ===');
        }

        // Close user profile modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('userProfileModal');
            const modalContent = document.querySelector('.user-profile-content');
            if (e.target === modal && !modalContent.contains(e.target)) {
                closeUserProfile();
            }
        });


        // GIF Picker functionality
        const TENOR_API_KEY = 'AIzaSyAyLGdwVFNawJ8km63NMV6p6m0NCCLlGek'; // Public Tenor API key
        let gifPickerOpen = false;

        function toggleGifPicker() {
            const gifPicker = document.getElementById('gifPicker');
            gifPickerOpen = !gifPickerOpen;

            if (gifPickerOpen) {
                gifPicker.style.display = 'block';
                loadTrendingGifs();

                // Setup search
                const searchInput = document.getElementById('gifSearchInput');
                let searchTimeout;

                searchInput.oninput = function() {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const query = searchInput.value.trim();
                        if (query) {
                            searchGifs(query);
                        } else {
                            loadTrendingGifs();
                        }
                    }, 500);
                };

                searchInput.focus();
            } else {
                gifPicker.style.display = 'none';
            }
        }

        // Close GIF picker when clicking outside
        document.addEventListener('click', function(e) {
            const gifPicker = document.getElementById('gifPicker');
            const gifBtn = document.getElementById('gifBtn');
            if (gifPickerOpen && !gifPicker.contains(e.target) && e.target !== gifBtn) {
                toggleGifPicker();
            }
        });

        async function loadTrendingGifs() {
            const gifGrid = document.getElementById('gifGrid');
            gifGrid.innerHTML = '<div class="gif-loading">Loading trending GIFs...</div>';

            try {
                const response = await fetch(`https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&limit=20&media_filter=gif`);
                const data = await response.json();
                displayGifs(data.results);
            } catch (error) {
                console.error('Error loading trending GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Failed to load GIFs. Try again later.</div>';
            }
        }

        async function searchGifs(query) {
            const gifGrid = document.getElementById('gifGrid');
            gifGrid.innerHTML = '<div class="gif-loading">Searching GIFs...</div>';

            try {
                const response = await fetch(`https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(query)}&key=${TENOR_API_KEY}&limit=20&media_filter=gif`);
                const data = await response.json();
                displayGifs(data.results);
            } catch (error) {
                console.error('Error searching GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Failed to search GIFs. Try again.</div>';
            }
        }

        function displayGifs(gifs) {
            const gifGrid = document.getElementById('gifGrid');

            if (!gifs || gifs.length === 0) {
                gifGrid.innerHTML = '<div class="gif-error">No GIFs found</div>';
                return;
            }

            gifGrid.innerHTML = gifs.map(gif => {
                const gifUrl = gif.media_formats.tinygif.url;
                const previewUrl = gif.media_formats.tinygif.url;
                return `<div class="gif-item" onclick='sendGif("${gifUrl}")'>
                    <img src="${previewUrl}" alt="GIF">
                </div>`;
            }).join('');
        }

        async function sendGif(gifUrl) {
            try {
                // Close GIF picker
                toggleGifPicker();

                // Show loading
                const messageInput = document.getElementById('messageInput');
                const originalPlaceholder = messageInput.placeholder;
                messageInput.placeholder = 'Loading GIF...';
                messageInput.disabled = true;

                // Fetch GIF and convert to base64
                const response = await fetch(gifUrl);
                const blob = await response.blob();

                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const base64Image = event.target.result;

                        // Send GIF message
                        const message = {
                            userId: currentUser.id,
                            username: currentUser.username,
                            avatar: currentUser.avatar,
                            imageData: base64Image,
                            imageName: 'animated.gif',
                            timestamp: Date.now(),
                            type: 'image'
                        };

                        let messagePath;
                        if (chatMode === 'public') {
                            messagePath = 'messages';
                        } else if (chatMode === 'private' && selectedUser) {
                            const chatId = getChatId(currentUser.id, selectedUser.id);
                            messagePath = 'privateMessages/' + chatId;
                        } else {
                            messageInput.placeholder = originalPlaceholder;
                            messageInput.disabled = false;
                            return;
                        }

                        await database.ref(messagePath).push(message);
                        console.log('GIF sent successfully!');

                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                    } catch (error) {
                        console.error('Error sending GIF:', error);
                        alert('Error sending GIF: ' + error.message);
                        messageInput.placeholder = originalPlaceholder;
                        messageInput.disabled = false;
                    }
                };

                reader.readAsDataURL(blob);

            } catch (error) {
                console.error('Error loading GIF:', error);
                alert('Error loading GIF: ' + error.message);
                messageInput.placeholder = originalPlaceholder;
                messageInput.disabled = false;
            }
        }

        // Gift Picker functionality
        const gifts = [
            { emoji: '‚ù§Ô∏è', name: 'Heart' },
            { emoji: 'üíù', name: 'Gift Heart' },
            { emoji: 'üåπ', name: 'Rose' },
            { emoji: 'üíê', name: 'Bouquet' },
            { emoji: 'üéÇ', name: 'Birthday Cake' },
            { emoji: 'üç∞', name: 'Cake' },
            { emoji: 'üéÅ', name: 'Gift' },
            { emoji: 'üèÜ', name: 'Trophy' },
            { emoji: 'üëë', name: 'Crown' },
            { emoji: 'üíé', name: 'Diamond' },
            { emoji: '‚≠ê', name: 'Star' },
            { emoji: '‚ú®', name: 'Sparkles' },
            { emoji: 'üéâ', name: 'Party Popper' },
            { emoji: 'üéä', name: 'Confetti Ball' },
            { emoji: 'üåü', name: 'Glowing Star' },
            { emoji: 'üíñ', name: 'Sparkling Heart' },
            { emoji: 'üî•', name: 'Fire' },
            { emoji: '‚òÄÔ∏è', name: 'Sun' },
            { emoji: 'üåà', name: 'Rainbow' },
            { emoji: 'ü¶ã', name: 'Butterfly' }
        ];

        let giftPickerOpen = false;

        function toggleGiftPicker() {
            const giftPicker = document.getElementById('giftPicker');
            giftPickerOpen = !giftPickerOpen;

            if (giftPickerOpen) {
                giftPicker.style.display = 'block';
                loadGifts();
            } else {
                giftPicker.style.display = 'none';
            }
        }

        // Close gift picker when clicking outside
        document.addEventListener('click', function(e) {
            const giftPicker = document.getElementById('giftPicker');
            const giftBtn = document.getElementById('giftBtn');
            if (giftPickerOpen && !giftPicker.contains(e.target) && e.target !== giftBtn) {
                toggleGiftPicker();
            }
        });

        function loadGifts() {
            const giftGrid = document.getElementById('giftGrid');
            giftGrid.innerHTML = '';

            gifts.forEach(gift => {
                const giftItem = document.createElement('div');
                giftItem.className = 'gift-item';
                giftItem.innerHTML = `
                    <div class="gift-emoji">${gift.emoji}</div>
                    <div class="gift-name">${gift.name}</div>
                `;
                giftItem.onclick = () => sendGift(gift);
                giftGrid.appendChild(giftItem);
            });
        }

        async function sendGift(gift) {
            if (!currentUser) {
                alert('You must be logged in to send gifts!');
                return;
            }

            toggleGiftPicker();

            try {
                const message = {
                    userId: currentUser.id,
                    username: currentUser.username,
                    avatar: currentUser.avatar,
                    gift: {
                        emoji: gift.emoji,
                        name: gift.name
                    },
                    timestamp: Date.now(),
                    type: 'gift'
                };

                let messagePath;
                if (chatMode === 'public') {
                    messagePath = 'messages';
                } else if (chatMode === 'private' && selectedUser) {
                    const chatId = getChatId(currentUser.id, selectedUser.id);
                    messagePath = 'privateMessages/' + chatId;
                } else {
                    alert('Cannot send gift. No chat selected.');
                    return;
                }

                await database.ref(messagePath).push(message);
                console.log('Gift sent successfully!');

            } catch (error) {
                console.error('Error sending gift:', error);
                alert('Error sending gift: ' + error.message);
            }
        }

        // Image modal viewer
        let currentImageMessages = {};

        function openImageModal(messageId) {
            const msg = currentImageMessages[messageId];
            if (!msg || !msg.imageData) {
                console.error('Image not found');
                return;
            }

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="image-modal-content">
                    <span class="image-modal-close">&times;</span>
                    <img src="${msg.imageData}" alt="${escapeHtml(msg.imageName || 'image')}" class="image-modal-img">
                    <div class="image-modal-caption">${escapeHtml(msg.imageName || 'image.jpg')}</div>
                </div>
            `;

            document.body.appendChild(modal);

            // Close modal on click
            modal.addEventListener('click', function(e) {
                if (e.target === modal || e.target.className === 'image-modal-close') {
                    document.body.removeChild(modal);
                }
            });

            // Close on Escape key
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    if (document.body.contains(modal)) {
                        document.body.removeChild(modal);
                    }
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        async function updatePassword() {
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmNewPassword = document.getElementById('confirmNewPassword').value;

            if (!currentPassword || !newPassword || !confirmNewPassword) {
                showProfileMessage('Please fill in all password fields', 'warning');
                return;
            }

            if (newPassword.length < 6) {
                showProfileMessage('New password must be at least 6 characters', 'warning');
                return;
            }

            if (newPassword !== confirmNewPassword) {
                showProfileMessage('New passwords do not match!', 'error');
                return;
            }

            try {
                // Verify current password
                const currentHashedPassword = await hashPassword(currentPassword);
                const snapshot = await database.ref('users').once('value');
                const users = snapshot.val() || {};

                let userFound = false;
                for (let userId in users) {
                    if (userId === currentUser.id) {
                        if (users[userId].password !== currentHashedPassword) {
                            showProfileMessage('Current password is incorrect!', 'error');
                            return;
                        }
                        userFound = true;
                        break;
                    }
                }

                if (!userFound) {
                    showProfileMessage('User not found!', 'error');
                    return;
                }

                // Update password in Firebase
                const newHashedPassword = await hashPassword(newPassword);
                await database.ref('users/' + currentUser.id).update({
                    password: newHashedPassword
                });

                // Clear password fields
                document.getElementById('currentPassword').value = '';
                document.getElementById('newPassword').value = '';
                document.getElementById('confirmNewPassword').value = '';

                showProfileMessage('Password changed successfully!', 'success');
            } catch (error) {
                showProfileMessage('Error changing password: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>
